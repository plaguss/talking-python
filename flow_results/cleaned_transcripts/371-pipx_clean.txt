I'm sure you're familiar with package managers.
For your OS, even if you don't use them on macOS. We have home brew, chocolatey on Windows and App Yum and others on Linux. But if you want to install Python applications, you typically have to fall back to managing them with with Pip. Maybe you install them for your account with the --userflag, but with Pipx, you get a clean, isolated install for every Python application that you use. And if you distribute Python apps, pipx is definitely worth considering as a channel. On this episode, we have Chad Smith, creator of Pipx, to tell us all about it, how it works, and how to use it. This is Talking Python to Me. Episode 371, recorded June 22, 2022.
A weekly podcast on Python.
This is your host, Michael Kennedy.
Follow me on Twitter, where I'm
@mkennedy and keep up with the show and listen to past episodes at.
Talkpython.FM and follow the show on Twitter via @talkpython.
We've started streaming most of our episodes live on YouTube. Subscribe to our YouTube channel over at.
Talkpython.fm/YouTube to get notified.
About upcoming shows and be part of that episode.
This episode is brought to you by Mergify, take control of and automate your GitHub workflows, as well as the Python At Scale Summit Conference being held in October. Reconnect with your Data Science colleagues this year.
Transcripts for this and all of our episodes are brought to you by Assembly AI. Do you need a great automatic speech to text API? Get human level accuracy in just a few lines of code?
Visit Talk Python.Fm/assemblyai.
Chad, welcome to Talk Python To Me.
Thanks Michael.
It's fantastic to have you here.
And many listeners are such a fan of Pipx and really just love to have that tool around to allow us to use Python libraries and commands like applications. And it's going to be so fun to talk about. And if you're out there and you haven't heard of Pipx, you're in for a treat. So before we get to that though, let's start with your story. How did you get into programming and Python?
So I got into programming back when the Internet was kind of like really popular GeoCities, like early web development type stuff.
This is the time when people had like the animated digging giphy and a lot of sites were still permanently under construction.
Yes.
And flashing text and stuff like that. So I thought that was pretty cool. I messed around with some GeoCities pages. I wrote a little bit of JavaScript to where you can hover over text and it will change the image and stuff like that. And I kind of messed around with web pages for a while, but I didn't really get too serious with programming with web development until later, much later. So when I got more into programming was in college.
I got a degree in aerospace engineering and so we did kind of like scientific computing. We used MATLAB a lot, so I used a lot of Matlab in college. And then in my first job we did a lot of MATLAB. So in the aerospace industry for making airplanes and control systems, we use MATLAB a lot. And so I kind of started hacking on MATLAB and making a bunch of programs and automating stuff, not really going into other programming languages, which were probably better suited for the job. I just kind of did everything in MATLAB.
That's the way I think most people do it, is they have a set of tools to pick from that they know how to work with them and they're like, well, which one of these is going to be best? And if you're programming environments MATLAB, then it's not a terrible choice.
Really.
Yeah, I got really into programming MATLAB and then eventually ended up in a job where I got to start doing a Python.
Nice.
What kind of airplanes were you working on?
First job was on the Space Shuttle, which has been retired. Then I worked on like I worked.
For Boeing, so of course, that's fantastic.
Yes, I worked on the 747 787, so I worked for Boeing, so Boeing worked on the Station all and as well as obviously a bunch of other planes. And then none of the Python work was there though. And the Python stuff started out as a start up funded by Google co founder Larry Page. So it's an EV tall electric vertical take off and landing plane. So it's like a small plane. It was a startup, it was a small company and we needed basically some tools to be made. And I didn't really know Python, but I like to just take on new challenges and learn new things. So my first experience with Python was with Python Two and working on the Django app. It was an app to track all the parts and weights and moments of inertia of the aircraft.
Right.
Another project was called a protocol compiler. So all the C code that ran on the Avionics, a lot of it was generated, a lot of the inter device communication was generated from this common protocol definition. And so this is all written in Python. So we could generate safety code, we could generate documentation about the code, we could generate tests where we had like hardware and the loop tests. And so that was where I started to run into issues with challenges, with packaging and getting dependencies installed on folks computers. Because if you wanted to build the flight code, you need to have a bunch of packages available.
Right.
And so you had to have maybe some foundational things in order, some libraries and other things. And you probably didn't want to teach necessarily see people how to set up Python and virtual environments and all that kind of stuff, right, exactly. Or documentation writers yeah, exactly.
And it was a small company, so there wasn't really a Python expert in house, so we kind of made a lot of the mistakes, and I had to go into the infrastructure side, too, and try to build all that out. And so I think we started out with pseudo pip install, and that was how we got our thing installed.
Yeah, for sure. Well, you talk about this small business or a small company you're at and sort of bouncing off the walls and just figuring out yourself, but you are also at Boeing, which is a non small company. From my looking in from the outside, I know a lot of people, they definitely dream of or look to get hired, these really large companies. And, yeah, I feel like there's a huge advantage to at least spending a little time in a company like this vital one you talked about where you're taking on a lot of responsibilities and you're kind of working together to figure out stuff rather than sliding into, like, a narrow slice of what's getting done. What do you think? What was your experience in those places?
Well, so Boeing did offer opportunities to let you kind of, like, improve processes and stuff like that, but the scope of what you're working on at a small company trying to build a similar product, when you have a smaller team with no legacy or decades of history building stuff, you're kind of just inventing it as you go. So, yeah, there's a ton of stuff to experiment with and take on and learn from.
Yeah. Cool.
How about now? You're at another small company, right?
Yeah, I'm at a small company called Meta.
I work for Reality Labs, and I work on developer infrastructure here as well. I work on things like language services, debuggers and Vs code extensions.
Cool.
Do you have any exposure to the Cinder project or any of the stuff going on over there?
No, I'm aware of it. I think it's super cool. But that's an instagram thing, really, and so it's not really something you say today.
Well, it looks like it's going to become a Python thing in little bits and pieces. Yeah, the pieces of it are being pulled over like we just talked about pep 690 and Lazy imports, and there's a couple of other things people are working to move in. Not the whole thing, but some of those features and improvements might get all of us.
Yeah, that's the great thing about Python is if you come up with a good idea, the community is very open and willing to adopt new ideas, the best ideas, when and can be continuously improving the language.
Yeah, it's pretty fantastic. So let's start our conversation here at a little bit higher level than just pipx, and let's just talk about packaging a little bit. So let me switch over here to this project you have over at Chadsmith Dev, which is a great domain name, and I'm impressed with a name like Chad Smith that you can get it just straight up as your domain name. Because as Michael Kennedy, all the Irish politicians are all over. I got to go with some crazy variation to come up with it. But yeah, that's cool. That's a great domain name. And over there at Python/packaging, you've got the big list of python packaging and distribution tools you want to tell us about. This kind of gives you a high level of what are the options, right?
Yeah. So a lot of times questions come up about what tools are out there, which tools do you want? It's a big world in the packaging, python packaging world. And I wanted to make something that was not opinionated and just kind of factual, like, here's some data, here's some information about this you can decide for yourself. It's not trying to persuade you to use this. It's not like saying, this is my tools. What's the best? And this came about from Pipx's documentation, where one of the questions on Pipx was like, what is it and how does it compare to other things? So I had kind of a list on the documentation, and it kept growing, and I was thinking this could be its own thing because I don't want to take that documentation too big.
Making a survey of all the other things that it competes with or could have been put alongside.
Right? Yeah.
So this is an interactive web app table type thing, and it pulls data from GitHub craft QL API, and it lets you kind of, like, select different features and filter on those. You can compare and group tools together. So on the top left, you'll see there's like a bunch of little blue words with blue backgrounds. And you can click on those, and if you click on them, then it will filter down the table. So if you want to find tools that have an install and publish, you can click on, like, install CLI apps and also publish packages.
Nice. This is a great little UI. It reminds me of an app I wrote once, and I'm having nice nostalgia here. It's cool. So you can sort of click on these little categories or filters and turn multiple ones on or off. So if I want virtual environment management, I can install libraries. Well, apparently there's none of those, but if I want to build packages and install CLI apps, well, I guess PDM is my choice.
Right?
That's cool. So maybe one thing that we could do that would be nice is maybe we could go through and highlight some of the more notable packaging solutions or options as we go through here, pipx being one of them. We'll get to that a bunch more, but want to maybe give us a bit of a rundown.
Probably the first really notable one is Conda. People are super familiar with that. Right on the data side.
Side. Yeah.
So Conda is kind of like a more ambitious way to create environments and it kind of makes its own ecosystem. I personally haven't used it, but I know it's pretty popular, like you said, with the scientific community. So it also can be used to make C libraries too interesting.
Yeah, it's certainly the claim to fame of Conda and Anaconda and Mini Condo, all those things is you don't have to have the build tools for all the libraries, the transitive closure of the libraries you want to use.
Right.
My understanding is it's its own packaging system. Like you don't pip install from it. There's some other parallel ecosystem.
Right, exactly. And I feel like to some degree with wheels, we're a little bit closer than we used to be with Pip directly.
Right.
Pip install wheel can just drop in a thing, whereas previously stuff had to happen on your machine to finalize that package.
Yeah.
Wheels are specific to your Python version, your operating system, and so yes, they can just be basically unzipped and used.
Yeah, that was fantastic. Except for the first couple of weeks of the M1 platform, the Apple silicon M1 try to install something. No, we don't have a wheel for that platform. What do you mean you don't have a wheel? Come on. I think that's pretty far in the past now. I haven't run into that problem for a long time.
Cool.
Another one on here that's clearly pretty popular. And in this C generating native code category is Cython.
Yeah, Cython is super interesting and it takes advantage of one of the pretty cool features of Python itself. So Cython can generate C code from Python code, and it generates shared objects, and shared objects are able to be imported directly from Python. So you can make a basically like a wheel that is native code built from your Python code. And if you have code that is really run really frequently, like a really hot path that Python is just a little bit too slow for you, you can really easily use Cython to convert that into C and make a shared object and then just use that. But just that module or just that function that you wanted to speed up.
There's some interesting examples of that. For example, UV loop, which is the fast drop in replacement for Async IO that was written in Cython and built on top of Libuv library, I think. Now here's one of those tight loops where this is the while true or the for in loop that does all the magic.
Right.
And so doing something like this makes a lot of sense.
Absolutely.
Yeah.
I was surprised how easy it was to use Cython. You can just basically run it, point out a file, and it just converts it to C and you can import too. It makes the shared object like it's just kind of like you just run the Command and It Just Magically Turns Into Something. Hopefully It All Works, but It Turns Into Something That Runs A Lot Faster.
Yeah, It Really Is Neat. If Use The Python Type hints, Get Even A Little Bit Better, or If You Go Farther, You Can Import The Cython Integer instead Of Just A Regular Int And So On.
Yeah, And Now Cython Has Typing In Pythons. So Python Also Has Its Own Kind Of Parallel Language where You Write, Like, Pip X File And You Have Cython Annotations. But Now With Type hints becoming More Prevalent In Python Itself, there Are Also Python Type hints which Allows You To Write Just Straight Python Code. But Cython Still recognizes How To Convert It to A Statically Typed C Type.
Right.
I Think That Makes It Way More Approachable For Many People because They Don't Feel Like They Have To Go Learn Something Different. They're Like, Well, If I Just Put Type hints On This, maybe Different Type hints. Yeah, We're Good To Go, which Is Pretty Cool. All Right, That Question From The Audience, From Jurgen. Hi, Chad. What About Build Out? Made Up Your Mind On Whether To Include It? What's The Story Of Build Out?
This On The Python Packaging Table. There Were Some Suggestions In The Issue Tracker, and One Of Them Was Around Build Out, and It Was Something I Hadn't Heard Of Before. I'm Still Considering Whether To Add That Or Not. I Think I Will. Leaning Towards Yes.
Okay.
I Don't Think I've Done Anything With Build Out.
Okay.
Very Nice. And Also I Saw That Py2App Could Get I Don't Think Py2App Was There, Was It?
It Wasn't.
Yeah.
So What's The Criteria For Being On That List? I Guess.
Yeah, I Just Kind Of Made it Started Just As A Comparison To Pipx, where People Might Be Confused Or Wonder Which One To Choose, and Then It's Kind Of Just Grown Organically, just Things I Thought Were Interesting Or Relevant. I Think There Should Be Something That Is Still Something That People Would Want To Use because There's A Lot Of Changes In The Packaging Landscape And There's A Lot Of Stuff That Kind Of Gets Left Behind that You Really Wouldn't Want To Use Anymore. There's New Tools Being Made, there's New Standards Being Fined. So I Want It To Be Something That's Kind Of Like Modern, Relevant, something That's Encouraged To Be Used. I Was Concerned It Was A Little Bit Maybe Older, and I Hadn't Heard Of It And You Haven't Heard Of It, so I Wasn't Really Sure If It Was Something that We Should Still Encourage Folks To Use Or Not.
Yes.
Here's Interesting. Have You Checked Out The Psf Developer Survey Results This Year?
I Have Not.
Yeah, So They Have A Section On Basically Which Tools Related To Packaging Do You Use? And They Break It Down By Popularity, which I Thought Was Pretty Cool.
That's Really Interesting. Yeah.
So for people just listening it's 81% of the people say they use Pip, and then 32% of people use Venv. I feel like that's pretty low. Honestly, it should be higher than what's going on there. But you've got 30% people use containers, 23% use virtual ENV, and then 22% condo. We got poetry, Pipenv Flit, PDM and others are like way down in the list there anyway. Does that strike you as what your mental model you had in mind?
A little bit, yeah, roughly. Just a few surprises in there. But I think all those should be in this table. If they're not, I'm going to have to check out the list.
Sure. Well, maybe not the container stuff, right? Because that's kind of like I have a virtual machine. Virtual machines are also there, right? Which I think means I have a virtual machine. So I don't care if I just trash it and just bust it. System they customize its system. Python.
This portion of Talk Python to me is brought to you by Mergify. It's an amazing tool to make you and your team way more productive with GitHub. Mergify is all about leveling up your post requests. Some of the features include automatic merges, you explain the conditions for an automatic merge and merge it  will take care of merging the pull request as soon as it's ready.
Automatic updates.
They merge your pull requests serially on top of each other, so there's no.
Way to introduce a regression.
Merge queues. Merge the urgent pull requests first, organize your PR priorities as you wish and.
Mergify will merge them in that order.
Back ports. Mergify will even copy your post request to other branches. Once the PR is merged, shipping your bug fixes in multiple branches automatically.
Merge.
Five features allow you to automotive what you would otherwise have to do manually. By saving time, you and your team can focus on projects that matter. Mergify is coordinated with any continuous integration and is fully integrated into GitHub. They even have a startup program that could give your company twelve months of credit to leverage mergeify that's up to $21,000 in value. Start saving time today by visiting Talkpython.fm/mergify to sign up for a demo and get started. Or just click the link in your podcast player. Show Notes thank you to Mergify for sponsoring the show.
For me. When I set up my servers, I don't do that. I actually create a virtual environment for the apps running on that server, or maybe multiple ones, but often it's just running one service. So I just create a virtual environment for it, just for the isolation alone. So it doesn't say, well, you can't use this version of some library because it's being used by some part of the system.
You can really cause yourself huge headaches messing with parts of the system. Like one time I think I tried to rename Python. I repoed my Python Three alias to different, like a newer version of Python Three, because I wanted to use that to just view it, what it used, and pretty sure my computer to start after that.
Yes. While I just have this page up, I just want to also show that Pipx does show up over here on tools for installing packages instead of managing it.
Very cool.
Coming along there. Pretty cool.
By the way, there is a pip I saw around not clobbering system installed where you have Ubuntu managing its own Python packages and you install to it or you uninstall something and kind of like mess up your whole system. There's a Pep out there to address that and to not mix things in there.
That's cool. I feel like almost ubuntu. And those different systems could say we're going to have our own isolated environment for our stuff. And what you want to do, even if you just run Python straight, that's going to do something else. But I don't know. I don't know the mechanics of making all that happen. There's a lot of pieces involved there. The isolation is definitely useful. Okay, back to the build stuff, maybe there's a couple of others here. Like, we've got the sort of what I would call Pip alternatives. We've got Flip and Poetry, right? Those are maybe the Flit and Poetry and Pipenv.
I guess those are all in a similar I know they might be painting that with too bright of a brush, but they're all about installing. Working with your environments, installing stuff into your environments for apps you're building, right?
Yeah.
Pipeline as well. And Hatch. It's quite a few.
Yes.
I'm not familiar with Hatch. Tell me about Hatch.
I have heard Hatch mentioned I think I've seen it around for a while. Never really used it. But then the creator of Hatch recently added a pull request to Pipx to use the Hatch back end. So with Pep 517 and 518, you can basically anything you want. Install your wheel, build wheels so you can have different back ends to build a wheel. So Hatch has one called Hatchley. This is actually now in the packaging, the Python packaging documentation. If you go to the Python Packaging website, I think it's packaging Python.org. There's instructions on how to build a package to distribute it. And it uses the Hatchling back end, which is a big achievement. Now, it's no longer telling you to use setup,py, but it's telling you to use this due to old build.
Right.
Which is also on your list, right? At the top.
Yeah. And it's alphabetical, so yeah.
Well, it went with, I guess, Venv maybe got a spot to still take the top notch there, but.
That's a good idea.
Nice. You do also have things like GitHub stars and stuff. Can you sort by them? Yeah, you can. Right.
I just added the star emoji, and I think it screwed up the sorting. So I'll have to work on that.
Oh, it's sorted by alphabetical, then with the start of the star.
Yeah.
Okay.
The challenges we run into.
This is really cool. Anything else you want to give a shout out to why we're here before we move on?
PyO 3 is super cool. I played around with that. So PyO3 is a way to call Rust code from your Python code. So kind of similar to Cython, except it doesn't generate Rust code for you. You have to have something already built and rest, but it's pretty easy to use. There's a really popular rust tool called Rip Grip, which is like Grip but rewritten and rust with a nice API, and it's super fast. And one thing I tried just to kind of, like, learn rust and learn IO three was to write an API in Python that called into the Rip Grip Rust code.
Right.
Okay, cool.
That actually worked pretty well. I was pleased with the development process and how fast it all ran.
Nice. All right, let's see one more bit of follow up on this that you're going out now. It says, Tox will also use hatchling with version four, which is pretty cool.
Nice.
Yeah.
I think that it's probably going to gain a lot more traction.
Yeah, it sounds like I need to learn about hatchling and hatch.
Pretty cool. Another thing that's interesting here that is sort of in the same space that we could talk about is pep 582.
To me, pep 582 feels a lot like node modules for Python. Sort of that where is the what is it? Project JSON and then the Node Modules folder next to it.
Right.
There's a folder, and it has a name. That's where your packages get installed to. And if you run Python commands below it, it will sort of traverse the directory up looking for that to find its effective virtual environment instead of the traditional virtual environment behaviors we all know.
Right, right. Yeah.
What are your thoughts here?
I sort of stumbled across this. I don't remember how I found it, but when I saw it, I was like, Oh, my gosh, this is incredible. I can't wait for this to land. I'm a big TypeScript developer. I like TypeScript like JavaScript, so I can kind of compare the two because I do a lot of work in both. And when I saw this, I was really excited.
Right, so you're like, this is the node version for Python.
Yeah. There's been a lot of headaches with global installs and globally installing packages and conflicting with the OS, having that extra step to always activate a virtual environment, create one or delete one to recreate a new one. It can get tedious, and it's also a bit it's part of the environment. Python packages is file on a file system. You know, it's there. If you want to start over, you just RMRF the folder and you can start over. So when I saw this, I was really excited and acceptance of it would be imminent. And we'd be using PyPI packages very soon.
I do too.
The next release. The world is different, right?
Yeah. And so you can see on the right yeah.
And it says this is targeting version 38. It's still in draft status. And that was 2018. So it's four years ago.
So one thing I want to mention is you mentioned this is like node modules for Python. And one of the authors of the Pep mentioned that he doesn't want folks to think of it like that, although it's not a bad analogy, but it's more like an auto activated virtual environment or automatically recognized. So he wanted to think of it like that because you didn't want to have nested Py packages where we can have this complicated nesting of each package has its own py packages, like a.
Fallback as you go up.
But to me, it seems like it would simplify a lot of stuff. For example, if I have a cookie cutter template and I want to just make sure that that project has its own environment, the cookie cutter could just create this folder at the top level and you're kind of good to go. You know what I mean? You don't have to do a bunch of virtual environment stuff. That's the one, right?
Yeah.
If you've got working with people who are new to Python, you can just say, Here, unzip this and run it. And it'll start out empty. But maybe the first step is to verify all the stuff is there. But you don't have to. It's just that bootstrapping to get started, which, as you gain experience, is no big deal. But I often encounter people who are new to this and they kind of bounce off it, which is unfortunate when.
You come across a project or when especially someone newer to the language comes across a project and they see instructions are pip install this thing. It's really kind of a loaded instruction to give someone because you might be basically breaking things in the process. You might be setting yourself up for some kind of failure.
Right.
It could get installed to their system. They might not have permission to install to the system. There's a lot of stuff going on there.
It also might install a version of a package that another tool requires a different version of. It will just kind of update it with what it needs. If there's an outdated version or something, they'll just give you a newer version which may inadvertently break some other tool. That depends on the older version for some reason, right.
All of a sudden, you fail to ban or your Firewall or something stops working. You're like, Why did that stop working? Or glances or some other tool. You're like, I thought that was part of my machine. Now it doesn't work anymore. And your little test project or tutorial broke it.
Right?
Yeah, that's probably suboptimal.
Yeah. So this was exciting to me because you could pip install something, I would go to this PyPI packages directory, potentially, and you wouldn't really have to worry about any other side effects or any color environment that you're affecting.
Maybe someday. Yeah, not for the moment. Well, we do have this other tool called Pipx that does manage this somewhat for a certain class of problems.
Right.
But this is more for building packages and applications and stuff, not so much external tools, but still.
Yeah, I think there are different use cases. I think this one is more for libraries. Like building your library or not necessarily the app.
Yes.
Well, you pointed out some implementations or experimental things going on with this one. So let's see here. So you got PyLoc here. This is you, right?
Yeah, that's fine.
So PyLoc is a drop in replacement that imports packages from this directory. And it's like an experimentation or an experimental implementation of this.
Right?
Right.
Yeah.
So I called it Python Lock. Was the idea, like, local location? It's for, like, local packages. I was thinking, I don't know. So they could be revised, I guess. But I saw the Pep, but I thought it was super cool and I thought, hey, maybe I can hack something together and let people try it. Because I think try discussing how something might work and actually using it is kind of like looking at a picture of somewhere you want to take a vacation and actually going there. Like going to a place versus just kind of like hearing description of it. So if we make something we can play around with, you can see, oh, I thought this would be cool, but it actually is way harder to use. Or maybe it's exactly what I thought I wanted and it's great. And let's accept the Pep. So I made this just as a way for folks to easily experiment with this kind of workflow.
Yeah, okay, great. And people can play with it. Although who knows where this idea is going. I still think it has legs, but yeah, it's been chilling for a while. And then there's PDM. I've heard of people using PDM and it seems like it follows the same idea.
Right.
Tell us about PDM real quick.
Yeah, so PDM is kind of like poetry. I mean, it uses Pep582. So it uses the packages directory. But yeah, it's similar in the idea of poetry or similar tools like Pipenv and all the ones you mentioned, Py Flow.
It creates and modifies the Py project toggle file. It can add its own metadata to it. It can build packages, it can publish packages. I'd have to consult that table. But yeah, I think it's kind of like an all in one tool that also uses Pep582.
Right, exactly. So it does a lot more. But it does happen to also use this idea. Right, right.
And in the Pep582 discussion on where all the folks are discussing the pros and cons, the developer of PDM mentioned that what his experience was with some of the tweaks he had to make to the pep to make it work for him. And I saw that there was some interest in it. And also, Py Flow is another tool similar to PDM. It's written in Rust. But I think Brett Cannon was interested in working with those two folks to maybe flesh out Pep582 a little more because they have some real world experience.
Okay, interesting.
Yes.
It doesn't sound like the Pep is dead. It sounds like it's stalled is more maybe how I understand it.
Yeah.
There are two original authors. One of them is no longer just in pursuing it, but the other is I think he's just been a little bit busy and hasn't had time to dedicate to it, but I think there's still potential for it.
Sure. Okay, cool. Well, let's move on to the star of the show, Pipx. How do you tell people about Pipx?
Pipx is a tool to install and run applications that happen to be written in Python.
I was going to say too.
I think of it as home brew or AppGet or chocolatey or one of these package managers where I just want to get this command or this application on my computer. I don't really care what it's written in. It's probably written in something tough that I have to install weird dependencies for, or I got to have some odd compiler and I don't want to deal with it. I know that if I type Brew, install Handbrake or something like I'll have that right. That's the way I see Pipx is there's all these cool commands and CLI's and utilities in Python, and they just happen to be in Python. We, as Python developers, care a lot that that's the case, but we just want the commands.
Right.
And with Pipx, you can just type Pipx, say install Pytest or Pipx, install Glances or some other cool library, and sure enough, you'll have it installed, right?
Yeah, that's the idea. One of the goals is to take away difficulty for end users to install a tool. A lot of times the instructions are like installed pip, and like I said, you can have problems with that. That's kind of a loaded instruction sometimes to give people, especially if they're not Python developers. As a Python developer, if you see that, you wouldn't really have a trouble managing that. But as a lot of folks, a lot of folks out there that just want the tool and the instructions are kind of like install, create a virtual environment. Now run the pip from that environment to install this tool. Now search into that bin path. And there's your binary. That's not really the easiest way to get end users a really cool program that you wrote that happens to be in Python.
Right.
I want to have this program accessible all wait, did you forget which in virtual environment you installed it into? And did you forget to activate that or whatever? Right, so this solves a lot of those problems, which is fantastic.
Again, as you said, install and run Python applications. Does this refer only to CLI or even web apps?
I'm not sure I understand the question. Certainly CLI apps. I'm not sure what a web app is in terms of this question.
Sure. Well, I guess maybe just kind of install stuff more broadly. Like, if I had something maybe that was built with GUI, for example, GOOI like that GUI framework. Or I have something that was built with some other tool that when I run it, maybe I don't get a CLI experience. Maybe it installs Flask and opens a browser or something like that.
Right.
I think that's the question.
Yeah, absolutely. That's actually where I found the need for pipx the most. And the tool I made that happens to be a web app where I have these. So the tool is called GDB GUI, and it's a web app that lets you debug programs with GDB.
Right.
And so I was writing the reading to tell folks how to get it, how to run it. People that are trying to debug things with GDB, maybe they're Python developers, but they're definitely see developers or Rust developers, some kind of a native language. So the reading instructions I wrote were kind of like, struggled with how to tell people to install this. Telling them to install Pip with Pip was not something I was comfortable with because there are so many dependencies GDBGUI has, and I didn't really want to break their system. There was kind of two fears. Like, one, I didn't want to mess their system up, and two, I didn't know if it would work reliably because maybe they would install something else and mess it up. I searched for a while to find something that could get this installed in a better way and found Pipsy.
Okay, so, yes, Pipsi like this Pip.
Pipsi is basically exactly what I wanted. It gives you a single command that creates a virtual environment installs package there, and that exposes the binary entry point, which sounds familiar because that's what origin is from.
Right.
And in fact, right at the top of the Pipsi read me, it says, Pipsi is no longer maintained. You should check out Pipx.
Right. The origin of Pipx came from one of the issues in Tipsy, where someone kind of having trouble getting changes merged to Pipsy. I found it, I was really excited, and I started making a bunch of pull requests on it, and I was having trouble getting things merged. And basically the maintainers, they were okay with having it in maintenance mode, but they didn't really want to do active development with it. And the owner, which was Armin Ronaker, he had sort of unsubscribed from the project and wasn't really following it, and so he was the only person that was able to give more access to let people become maintainers and so on. So we weren't able to add ourselves as maintainers. So we're kind of stuck with this tool. Like, maybe we could fork it, maybe we could make a new tool.
Yeah.
So how did you get from there to Pipx?
As I said, I was like, I'm into also TypeScript in the JavaScript community, and one of the tools they have there is called NPX, which is pretty similar to Pipx. It lets you run CLI apps from Node, who also can have similar challenges because it's an interpreted language.
I made Pipx kind of add that capability to Python, and then I added the ability, since it does kind of like it makes a virtual environment, it finds the binary in it and it runs it. It's very similar to installing it. It's basically installed a temporary place and runs it versus installing it in a permanent place. And so I added the install capability on Pipx. I shared it with some of the folks in the Issue Tracker, and they were like, this works for me.
Let's go use that. And that's it. Yeah, the momentum continued around it and had a lot of really great contributors work on Pipx.
Yeah, it's great. The GitHub reposit 75 contributors and 5000 GitHub stars, which is pretty awesome.
Yeah, I'm really happy with it.
This portion of Talk Python to me is brought to you by the Python at Scale Summit. The Python at Scale Summit is a conference to highlight innovative big data solutions for Python developers and enterprises. You'll learn about trends in the Python big data ecosystem, share stories about implementing solutions, find out about new innovations, and connect with other data scientists using Python. The Python at Scale Summit will be a hybrid conference with talks, workshops, and training. Of course, there will be networking and social events to connect with other Python professionals too.
Come here speakers like Matt Rocklin from Coil, Brian Granger from AWS, and many others from amazing organizations such as NASA, Capital One, and BCG. Get back together with your peers and learn how they're scaling their computation and data analysis using Python and the Data Science Stack. Register at talkpython.FM/pythonatscale. When you visit the link, be sure to use the code Talk Python All Caps to get 15% off your tickets. That's Code Talkpython at talk python.fm/python at scale. The links in your podcast players show Notes thanks to the Summit for supporting the podcast.
I use it all the time. I personally really like it, and I'm really glad to see other folks are enjoying it as well.
Yeah, I use it all the time. It's one of my go to tools. When I want to check out something I know is built with Python as an application. Or I get a new machine. We can talk about some of the fun stuff to install in a little bit, but maybe let's first talk about what happens and how do I use Pipx? What's the process? You do have a nice animated GIF on the GitHub project, so people can see what happens, but maybe walk us through it. Like, let's say Glances. Glances is a fantastic application that you can use and if you run it on your machine, it gives you this super rich terminal based real time view into your servers. Much better than Top or something like that. It also has a web view and whatnot. So that's a thing that people might not care about Python for, but it happens to be written in Python. So it's a perfect thing to PIPX install.
Exactly. Yeah.
So talk us through know fire Pipx install Glances. What happens?
Yeah, sure. So the first thing is Pipx will try to determine which package you're trying to install. So you can give it just the name Glances, or you can give it basically any pip specifier, any kind of it can be a Git repository, it can be a wheel. Anything Pip can install, Pipx can install. So first we'll make sure that it's a valid package specification. Then it will create a virtual environment in this directory that Pipx manages. So it will make a virtual environment with the name of the package that will make a Glance as a virtual environment. Then it will do some introspection that it will install Glances into the virtual environment. So now we have a virtual environment with Glances installed, but it's not accessible anywhere other than inside that virtual environment. And so the next thing it does is it does some introspection on the virtual environment to say like, what binaries do we have available? And so it would be expecting Glances to be available. And it will then take the path to the Glances binary and create a similar into a directory on your path on your shells path. So that when you run that command, it's available.
Right.
So, for example, you need to have in your little example here was home/csmith local bin. And then that's the folder where all the similar stuff gets linked over. You can also do those with entry points, right? It'll find the entry points and make them available.
Yeah.
So these are console scripts. These are entry points. These are the console scripts.
Okay. So that leads me to a question out in the audience from Rachel says, this looks great. Not sure if I missed it, but how do you get your built Python app to be Pipx installable? So you said it has to be pip installable, but then I think the other point here, you would have to expose some functionality in a way and that could be entry points, right?
Yeah.
So pretty much that is essentially the only way is the console script entry point. So you can look this up. It's a well defined part of the packaging specifications, but you can define a function that you want to call from a console script entry point.
Yeah.
So in your setup, you would say something like, setup tools set up entry points equals, and then you give it a list of a command and then basically a module colon function.
Right.
So here this example that I'll link to in the show notes. Hello, world equals hello, world, which is the module name colon say hi, which is a function in hello, world. And once you install that into a virtual environment, you could just type hello, World, and it would do whatever it does for that function. But what you're saying is, if you install with Pipex, it finds these and creates basically binaries that the system can see that it thinks it can run, called Hello World, for example.
Yeah.
When you install something that has a console script, it makes this like a shell script that calls that function for you. And so these shell scripts just get some linked out onto your path by pipebacks.
Got it.
Yeah.
So it's basically doing the install. It's creating the virtual environment automatically behind the scenes. It's doing basically pip install on the package, but that drags in all of the dependencies. But the important thing is, every one of these commands, or I guess the thing you pipx install, it can have multiple commands as part of it. It gets its own virtual environment that's isolated not just from the rest of the system, but all the other pipe things as well. So they're versioned and they live independently, right?
Exactly. You can have more than one console script, too. A lot of times, package will have two or three, four console script entry points, and Pipex will find all those.
Nice. Yeah.
One that comes to mind is Py Jokes.
Pi Jokes?
Yes.
I've heard you guys talk about that before.
Yeah, Pi Jokes is a good one. So this one has entry points, and I always get this through pipex.
Pipex install Pie jokes, and you end up with a bunch of here they say pipe us all. I should say pipex.
Right.
And then you can run Py Joke or Py Jokes, even as a program API, and you get really deep jokes, like, why did the programmer quit their job? Because they didn't get a raise. A raise is in list.
But it's those types of things.
Right.
You don't necessarily care that Py Joke is written in Python. The name would maybe make you think it should be. But you just want to have a command that you can type something and get a funny programmer joke out of it.
Right.
But maybe we could touch on some of the other things that are more useful than Py joke.
One you mentioned was the Gdbgui. I gave a shout out to Glances, because Glances, I said, is fantastic. I use Glances all the time, it just happens to be written in Python. But I just want it on my server. Maybe another one that you pointed out was HTTPie HTTPie. Do you use this one?
I have not used it too much, but I would love to find an opportunity to use it preferred over things like Curl.
Yeah, I love HTTPie. It works just like Curl in a lot of ways. But the results that it gives you, it gives you syntax highlighting, easy ability to say just show me the headers and the response headers and stuff that came back and cookies. And it does highlighting on those. It's really nice. Just pipx install Http and then you get Http as a command and Https. Here's another one with two entry points.
Right?
So if you just want to say Http 12701, you don't have to say Httpservername. You can just say the command either Http or Https and it'll do. It just a little bit shorter.
Right.
So this one big fan. But what was surprising to me about this is this is backed by a company, right? There's like a whole bigger organization behind acquired than I realized, I believe.
Yes, I was impressed with their website. It was a lot more polished than a lot of other open source projects. So I'm not surprised to hear that they're funded or part of a company.
Yeah, exactly. At the bottom it says there's a whole job section. There's apparently four jobs for AC Prom. It's just incredible at the same time. It's a fantastic tool. So good on them. Let's see, maybe some of the other ones. I know we had a little bit of a list of stuff that could be fun Py installer Py2app. Let's see, Py installer Py2app Cython. A lot of the package management stuff, poetry, pip, anything else you want to give a shout out to? I've got one I want to as well, but go ahead and do yours.
Another program I made, I guess I'll plug my own projects, it's called Term Pair. So this is actually kind of a web app that lets you share your terminal session through the web, but it does it by encrypting all the output and input from your terminal. And so basically you run this command term pair share, and then it will start sharing through this server and then you can control it from the web app or you can control it from terminal. And the process running in the terminal is a Python app and then of course, the web app is Javascript react. React?
Yeah. How interesting. Does it give you your normal shell or is it like a bare bash or z shell or something?
By default it uses like if I.
Do a super configuration of my shell, make it all blinged out and then I run this, do I get the same crazy configuration or is it a simpler version?
No, it's the exact same thing. It'll just run whatever shell whatever the shell environment variable is that you're running. That's the default command. You can run any command you want. If you want to run Python, you could run Python and it will share your Python session. You can run anything, really. But if you run a shell, that's the most familiar thing, I think, for sharing.
Sure. Interesting.
It'll share basically any CLI thing.
It spawns a Pty process and then any output or input just gets written and behaves like any other terminal would. So you can do stuff like this is h-top where you're interacting with it. It's kind of like rewriting lines to the screen and it's able to handle all that.
It might be a nice way to help people. Like, you know, I'm stuck. I can't get this to work. You're in an email exchange or zoom meeting or something. Run this and give me the link and let me just ask your system a question real quick and see if it does seem you got to have a lot of trust to give this over to people though, right?
Yeah.
I made it because it seemed really fun. It was a challenge. It seemed fun, practically speaking. I don't know how often it's used. You'd have to totally trust somebody to not I mean, they have full control over computer.
Sure. It's not that different than going to a zoom meeting and say allow so and so to Share to control my mouse and keyboard or team viewer or something like that, but still pretty neat. I know it's just a more visceral right there. You can just RMRF it right there. There's another one I want to pull up here.
This one.
Do you use Pls any?
Yeah, I've tried it out. It's pretty cool. I like that you can do so many different things. I like how easy it is to develop applications in Python where you can just kind of make whatever customizations and hack things up really quickly.
Absolutely. So Pls, it's a little hard to see over the screen. Share, it's a replacement for LS, and I know there are many replacements for LS, but this one is cool because it's like a developer friendly one. And so when you interact with it, it will use a lot of different things. For example, to show icons for Python logos next to PY files, JavaScript logos next to JS files, and so on. But it will also use like Git ignore files to decide what shows up in the basic view. It will show you the Git status of the file when you do a POS dash details, you'll see which files in that listing are modified and get according to Git and so on. So there's just a ton of fun stuff here that you can check out. I definitely think it's neat. Here's some examples of some of the colors. Like, for example, Poetry Lock, because it's git ignored, but still important. It shows up, but it's like a very faint color, whereas other files show up with regular color. So this one is another one that's good to pipx install, right? Because you just need it once for your computer.
Yeah, I love those colors, too. Great color scheme.
Yeah, absolutely. And apparently you can build little plugins and stuff for it, I think in Python, I haven't tried to do that. I've just tried to use it as a user. But yeah, that one is a fun one. For a while, I replaced LS with it. That wasn't a super idea because it behaves weirdly.
If you try to LS something and it doesn't exist, you get a trace back exception. Instead, it just doesn't exist anything. It's not perfect, but as a thing that you have hanging around, it's definitely quite neat.
Yeah. Replacing system utilities can get kind of risky.
Yeah. You just got to know what you're doing. I'm willing for this to mildly break stuff, but if you make it like you said that one time you couldn't turn on your computer, then you're in a bad spot. If you could at least get back and edit your profile, your shell profile, and turn those back to normal, then you're probably okay. Yeah. Well, maybe real quickly you could give us just if there's any interesting internal, there's some interesting tools or stuff that happens behind the scenes with Pipx gives us a look inside real quick, and then maybe we could wrap things up.
Any interesting internals or pip?
Yeah, like notable libraries that uses or something that's really valuable in there. I was poking around the pip project table, and there's like, arg Complete sounded interesting to me, and then a user path is new to me as well.
Okay, yeah, sure. So, Argcomplete, I'm a huge fan of our Complete is a package that so if you use Arg Parse, which is the standard library's argument parsing package, a lot of times you'll want to have, like, tab completion, and tab completion can be really hard to write. And so Arg Complete gives you a Python API to tell it how tap completion should work. And so Pipx's case, if you're going to do something like Pipx, like uninstall a package, you have to give a name of a package that's been installed. And so with our Complete, you can say, like, pipx uninstall tab, and then our Complete, you give our Complete a list or a way to get a list of packages that can be uninstalled, and then it gives you that tab completion just like you'd expect, and it also does it across shell. So writing it for just bash is enough to do, but then you also have to write different completions for fish or something like that. So our Complete lets you not think about that and just use your armparse as you normally would, which is like a couple extra arguments and then boom. You have tab completion, right?
Yeah. There's a whole section where you talk about how to install a Completion in here for the shells. So if you just type pipx completions, it'll tell you how to do that.
Right, right. And our completion is useful for I mean, I actually added it for Knox. I'm a big fan of the tool Knox, which is also Pipx installable and knox a lot of times. There's a lot of sessions. You run sessions in Knox and there's a whole bunch of them. And so having a tap completed on that is if Charlie wanted. And I think that's where I first found out about our complete, and then I started adding it to other projects after I found out how easy it was to use.
Right.
You're like, this is not that hard. I want this to be yeah, cool. The other thing that people need to remember to do is to run Pipx insurepath. Right, right. Because we talked about that local bin and your user profile, at least on Mac OS, I know that's where it goes. It might go somewhere else in Windows, but you want to make sure that's in your path. So that'll basically modify whatever your Active shell profile is to make sure it's in your path.
Right?
That's right. Yeah. And you can also modify how that binary directory is with an environment variable if you want.
Okay. How well does this work on Windows as well? Does it work there? Is it like PowerShell friendly and stuff like that?
So it does work on Windows. I know that one of the contributors is one of the maintainers is a Windows user, and I don't see a flood of Windows issues coming in. But this doesn't work on Windows, so it should work on Windows.
Yeah, perfect.
Okay.
And then it can upgrade itself if you do Pip upgrade, like user or something like that.
It doesn't install itself. I was considering making a new installer where Pipx installs itself with Pipx, but I'm not sure I'm going to land that right now. We install Pipx with Pip, and so you would just upgrade it normally with, like, Pip upgrade?
Sure. Okay. Or it's Pip installed as another thing.
That I like about Pipx is you can just say pipx. What is it? Upgrade all?
Yeah.
There's a command to just upgrade. You know what, get me a new version of all my libraries, which comes back to similar with apt. Similar to home brew. Right. There's a brew update and outdated. And just show me the stuff that could be updated and we'll just do it. Same with chocolatey, just to keep the tools used fresh. It's really nice.
Yeah.
It kind of goes back to like, I have this program. I don't really care about that. It's where the python is. Want this thing to work? I want the newest version of it and just kind of make it happen.
Right.
But if we reverse that and we're talking to Python developers, as most people listen are, you can empower people to deliver their applications to end users in a way that is much, much simpler if they're not Python people.
Right? Yes.
If they can get pipx on their machine, then getting the rest of the stuff is basically done.
Right.
That's a great point.
Yeah.
I mean, the distribution story gets a lot easier for your users. If you're a developer and you want to get this in people's hands, having them use Pipx is going to cause them less headaches, and it's going to cost you less headaches because it's going to be more predictable environment to install in, because pipx kind of lives in the center of few things. Like, you have wheels, which are pre built packages specific to your operating system, and you have pipx and virtual environments. Pipx kind of marries them all together in a way where it takes the prebuilt doesn't have to rebuild it on the user's computer. It takes this pre built thing that works. It puts it in a place that's not going to disturb anything. It's not going to get disturbed either, and then it makes it accessible to the end user, and they don't have to think about any of those pieces to get it on their computer.
Yeah. So maybe one of the biggest takeaways is if you're trying to deliver Python applications to people, here is a really good option if some kind of CLI starter is the way to go.
Right.
I guess if you want, here's how you drag it over to your applications folder and put it in your dock. Maybe that's not the right thing, but for a lot of the type of stuff people are building with Python, it's a great way to get it to end users and keep it up to date.
Yeah. One other thing I'll call out is pipx Run.
Yes, we talked about install the whole time, but yeah, pipx run is maybe even better for certain things.
Yeah.
So pipex run will make sure you have a recent version of the tool you're trying to use. So if you want to run some kind of a bootstrap program or some kind of, like, cookie cutter where you create a new project or something like that, and you'd want it to run with the recent version, we'll just kind of make it happen for you.
Right.
So one of your commands might be, well, first you're going to set up a virtual environment, and then you're going to pip install cookie cutter, then you're going to run cookie cutter this thing. Right, right. Well, maybe the step is, if you already have pipx, assuming this is a thing that's successfully pipx install run cookie cutter, and you give it that command, nobody needs or wants cookie cutter. After that, they just need cookie cutter to run the skeleton generator for their project, and then their project is kind of free from cookie cutter because you can't update your project afterwards anyway.
Right.
That's probably a good mental model to have.
Yeah.
And that's how the JavaScript world uses it. It's kind of like it's one of the really popular ways. And you'll see that NPX create react app is a way to start react apps with the latest version of that cookie cutter type thing. And so I would love to see more adoption on that side in the Python world.
Yeah, absolutely. Another one. I guess that's just real quick. Maybe give a shout out to this is the NodeJS thing that just got added. Isn't there a way that just came out for installing NodeJS as a dependency, not just the bindings? I feel like there just was.
Yeah, I saw something about this.
Yeah, actually, I think we just covered it on Python bites, but I wasn't the one who brought it up, so I don't totally remember. Let's see. Here you go. NodeJS dashboard. That's it. Do you know how to get covered it? And yes, there it is. Node JS dash bin. So if you've got something that needs to have the new tools around or CLI stuff, you can just pip install NodeJS dash bin. So I guess you could also pick an X install NodeJS dashboard.
Yeah, maybe if it's an entry point, then for sure.
Yeah.
I haven't thought enough about it, so maybe it doesn't quite fit in there, but it's an interesting development. All right, Chad. Well, I think we're probably out of time for talking about Pipx. Let's maybe wrap things up. Any final thoughts or anything you want to add to this before we get to the final two questions?
No, thanks for having me on and sharing some discussion on Pipx.
Yeah, absolutely. It's a great tool. All right, final two questions. If you're going to write some Python code, if you're going to work on Pipx or your terminal replicator or whatever you're doing, what editor are using these days?
I use VS code.
Yeah, it sounds like Meta is pretty standardized on that. Is that right?
That's our company wide editor do a lot of work on writing extensions for it and making it work for developers in Meta.
Yeah, cool. And then we've talked about a ton of PyPI packages, but one you want to give a particular shout out to.
Yeah.
So this one is not Pipx installable, but I think it's super cool. MK doc strings. And this is a way to generate documentation from your code. I think it's similar to Sphinx. I haven't really used Sphinx too much, but I find mkdoc string is really user friendly. It's all marked down, and I think it's really like a good looking UI that it generates for you. I think it's really easy to use and gives you a nice end result too.
Fantastic. Good recommendation. All right, final call to action. People want to play with Pipx, develop Python apps that can be installed through Pipx and so on. What do they do? How do they get started?
How they get started developing apps for Pipx. So you can use any of those tools to get a Pyproject.yaml file and have a publishable package. And make sure you have a console script entry point. Really, all you have to do is have a console script entry point for your package, and then Pipex will take care of it for you.
Yeah, it's worked with everything that I've tried it with, so it seems pretty solid.
Great.
Awesome. All right, well, thanks again for being here and for working on Pipx. It's a great project.
This has been another episode of Talk Python to me. Thank you to our sponsors. Be sure to check out what they're offering.
It really helps support the show.
Mergify is an amazing tool to make you and your team way more productive. With GitHub, it's all about leveling up your pull requests with automatic merges, auto updates, PRQ, prioritization and backwards, you'll tame.
Your PRS once and for all.
Get started at Talkpython.Fm/mergify.
Sign up for the Python at Scale conference to connect with your data science colleagues and learn about trends in the Python big data ecosystem, share stories about implementing solutions and find out about innovations in our space. Visit Talkpython FM/Pythonatscale.com Python at Scale and use code Talkpython to get 15% off your ticket when you.
Level up your Python.
We have one of the largest catalogs of Python video courses over at Talk Python. Our content ranges from true beginners to deeply advanced topics like memory and Async. And best of all, there's not a subscription in site. Check it out for yourself at training talked Python FM. Be sure to subscribe to the show, open your favorite podcast app and search for Python. We should be right at the top. You can also find the itunesfeed at /itunes, the Googleplayfeed at /Play, and the Direct rss feed at rss on talkpython FM.
We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at Talkpython.FM/YouTube, this is your host, Michael Kennedy. Thanks so much for listening.
I really appreciate it.
Now get out there and write some Python code.
