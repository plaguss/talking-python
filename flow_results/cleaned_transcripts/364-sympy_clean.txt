We're all familiar with the data science tools like NumPy, Pandas, and others. These are numerical tools that work with floatingpoint numbers, often to represent realworld systems. But what if you could exactly specify the equations symbolically, like mini any of us did back in calculus or differential equations courses. With Simpai, you can do exactly that, create equations, integrate, differentiate, and solve them. Then you can convert those solutions into Python or even C and Fortran code. We're here with two of the core maintainers, Ondrej Sertik and Aaron Meurer, to learn about SymPy. This is Talk Python episode 364, recorded May 6, 2022.
This episode is sponsored by Microsoft for Startups Founders Hub. Check them out at talkpython. Fm/foundershub to get early support for your startup, and it's brought to you by Sentry. Don't let those errors go unnoticed. Use Sentry. Get started talkpython.com /sentry. Transcripts for this, and all of our episodes are brought to you by Assembly AI. Do you need a great automatic speech to text API? Get human level accuracy and just a few lines of code? Visit 'talkpython.fm/assemblyai'.
Andre and Aaron, welcome to Talk Python to me.
Thanks for having us.
Yeah, it's great.
Yeah, it's fantastic to have you both here.
What a cool topic.
Symbolic math with Python. I think I'd heard of SymPy before, but I didn't fully appreciate how neat and how advanced it really was. So people are going to enjoy diving into this and we can talk some internals and whatnot. And if you're doing anything scientific or computational, this is certainly a project worth checking out. But before we get to that, let's just hear your story. How did you get into programming and Python? Aaron, you want to go first?
I've always kind of been into computers ever since I was a little kid. I actually started messing around with programming and Apple script in my family's Macintosh back when I was a really little kid. Nice, but didn't really do any serious programming until College, when I started doing taking computer science courses. And actually for Python.
My College had a free course that they were offering to teach this little language called Python.
The CS course that I was taking was in Java and C, and those languages wasn't a huge fan of those languages. But I learned about this language called Python, and I thought it was great. I was immediately hooked with Python just because it's so easy to use. It's so easy to just write a program, and you don't have to worry about compilers or all this boilerplate.
Yeah.
I've always been a little suspicious of languages that described them selves that way, which is ironic given how much I do with Python. But so often when you hear that, it's like, oh, it doesn't need all the symbols, and it's super easy to get started. That means, like, oh, it's really easy to do easy stuff, but then you can't do interesting things. And I think one of the things that's special about Python is like you can keep going. You don't have to stop once you need advanced ideas. That's pretty awesome.
Yeah, it really is.
You're right. A lot of languages kind of stop, but Python, it's got a lot of advanced stuff as well, and it's got a huge ecosystem of libraries. You can do just pretty much anything you want in it.
Yeah, for sure. The big paradox for me is there's a joke T shirt that I've seen that says, I learned Python. It was a great weekend, which I think is kind of true. You can do that. But at the same time, for many years now, I've been studying Python, and there's still just so much more to learn one about the language. And also just like, as you said, all the different libraries, like, oh, I want to learn Pydantic now or this other thing or so on. Very cool.
All right.
How about now? What are you working on day to day?
Yes. So I work at a company called Quansite.
We do consulting, mostly around open source Python open source data science stack.
I work about 50% of my time on SymPy as part of a grant, which we might talk about later, I think.
And I also work on different consulting projects, actually, right now I'm part of a project called the Data API's consortium, which is trying to standardize the array API libraries for different Python array libraries.
The APIs for those like NumPy and Xray and those types of thing.
NumPy, PyTorch, Jacks, QPython. So the idea is that all these libraries have very slightly different APIs, and it makes it hard to write code that just works against all of them. So what we're doing is creating a standard API that all of these libraries will target. So you can write code that will just work with NumPy, but you can also just instead of importing NumPy, you can import Qpy. And that same code will run on the GPU, for example.
Oh, that's fantastic.
Yeah.
That's a really good, ambitious goal.
It sounds so easy. I'm sure it's pretty challenging.
Yeah. Well, I think we're being successful. We just released the first version of the specification, and we've got several libraries that are implementing it already, including several others. So I think it's been a successful project, and it should really help push the Python data science ecosystem forward.
Yeah, it sounds like a definitely a good step. Andre, how about you? How did you get in the program in Python?
High school. I was trying to figure out when I got into it, I think at high school, I don't know, I don't remember how I found it. But it was only 2000, so I'm guessing it was before. NumPy I think that was number eight. I think the library Python and dream I had regret. I was studying physics.
I wanted to play with mathematical formulas in Python so that's when I start to SymPy. And then I use Python pretty much probably close to 20 years now or over 20 years.
And I cannot say I'm an expert.
It wasn't a good weekend.
I don't know, whatever stuff I'm not that great at, but the basics I would say I know pretty well.
Sure.
After my PhD in Physics, I went to work at Los Alamos National Lab for about eight years computational physicist.
I use Python. I use a lot of Fortran, a lot of computational goals and a lot of C++ sounds fine.
There's a lot of Python stuff happening there at Los Alamos.
Yeah, it is the network X. I think libraries started here very recently. Half a year ago I changed jobs.
I now work at a company called GSI Technology which is a hardware vendor. As a compiler developer, I started this compiler Fortran called L Fortran.
It's a compiler for Fortran, but it also allows you to use it interactively, just like you would Python. It's a notebook as well as the kernel.
And at this new company we are also in addition to creating a new front end called L Python which takes Python what's compiled is through the same pipelines, through the same intermediate representation, and all the back ends, all the code is the same. So effectively it treats Python like Fortran, so the same speed and so forth.
Oh wow, that sounds awesome.
It is awesome.
Very, very cool.
Alright. Well, super fun to be talking about SymPy with you all today. Symbolic math. I want to start this off though with right up from Aaron. That is maybe not what people would expect is the first topic to introduce. SymPy simply has been in the news a little bit for the wrong reasons recently, right, Aaron?
So it was even on the front page of Hacker News because this company, Hacker Rank, reached out to GitHub sounds like through automated ways and said we seem to see some math that looks like questions we might ask or something like that. So we need to completely ban SymPy because they're stealing our interview questions or something like that. Right? Give us the story. What kind of madness was this?
Yeah. So we sort of just got this notice from GitHub that a DMCA takedown had been issued against one of the pages on our documentation. And the way the DMCA works and the way GitHub's DMCA policy works is when somebody issues a notice, they basically just have to take it down.
And GitHub basically took down the entire documentation site for about 12 hours. And so I've got a timeline of everything that happened here in this blog post.
But basically they had some company that they were working with to try to find their solutions on GitHub and issued DMCA takedown notices against them. And somehow this worth IT solutions company decided that our docs was one of these and they just issued the notice.
And so it ended up taking down our documentation, which immediately, like you said, it made it to the top of Hacker News.
So outrageous.
Yeah.
The notice itself, it was completely ridiculous.
The stuff that they were claiming was their Copyright is probably not even copyrightable. Like, if you look at the examples on that documentation page that they took down, they're just like simple math examples.
Yeah, it was like X squared minus two solution is negative plus or minus radical two, you shouldn't be able to Copyright. I think that actually predates Hacker Ranks Foundation.
Hacker Rank as a company.
Yeah. So the CEO of Hacker Rank, I guess, notice the buzz that was being made about it and retracted the notice. So the docs ended up going back online about 12 hours later. If they hadn't done that, we would have had to issue a counter notice, which would have kept the docs offline for about two weeks before that counter notice would have taken effect. And that's just because of the way the DMCA law works.
I also explained how the DMCA law works in this blog post. If anyone's wondering, like, why would GitHub even do this? Like, well, they're kind of required to do this kind of stuff by law. There are some ways I think they could have improved what they did here, which I go over as well.
But the CMA pointing those out. Yeah. The DMCA provides what's called safe harbor for places that host user generated content. Basically YouTube, social media places. Github clearly has a ton of user generated content that's public.
If you got the source code of Windows or something and you posted it up there. Right. Theoretically, Microsoft might say, you know, we don't really want you hosting. This is not supposed to be open source. Please take it down. Right. So that's the idea. The way it works, though, is basically once there's a request to take it down, they just have to here's the part that I think that got missed. Decide that it's a valid request and then just take it down. Like they don't really try to negotiate or determine the correctness of that assertion. Right.
Yeah. So they sort of have to stay as a disinterested third party, I guess.
And the reason is that in order for them to have the safe harbor, the safe harbor status sort of frees them from the liability on either side if there is a Copyright claim or if there's a lawsuit or something, they can just say, okay, well, we're just hosting the content.
The law sort of allows them to do that. But in order to do that, if they get a DMCA claim, they have to just take it down and then if there's a counter notice issued, then they can put it back up. And the DMCA has these DMCA sort of tells them that if they get a claim, they have to sort of take it down expeditiously. And if there's a counter notice, they have to put it back up in ten to 14 days.
There's a lot of parts of law that they sort of have to do. There's some things I think that they could have done better, and there's also some things that they already do which they don't have to do, which are nice, including they have a repo where they actually post every single DMCA notice that they've received going all the way back to 2011 actually.
Interesting.
So you can actually see all the DMCA notices that have been issued against GitHub repositories on that repo. That it's. Github.com Github/dmca.
This portion of Talk Python to me is brought to you by Microsoft. For Startups Founders Hub Starting a business is hard. By some estimates, over 90% of startups will go out of business in just their first year. With that in mind, Microsoft for Startups set out to understand what startups need to be successful and to create a digital platform to help them overcome those challenges. Microsoft for Startups Founders Hub was born. Founders Hub provides all founders at any stage with free resources to solve their startup challenges. The platform provides technology benefits, access to expert guidance and skilled resources, mentorship and networking connections, and much more. Unlike others in the industry, Microsoft for Startups Founders Hub doesn't require startups to be investor backed or third party validated to participate. Founders Hub is truly open to all. So what do you get if you join them? You speed up your development with free access to GitHub and Microsoft cloud computing resources and the ability to unlock more credits over time. To help your startup innovate, Founders Hub is partnering with innovative companies like OpenAI, a global leader in AI research and development, to provide exclusive benefits and discounts through Microsoft for Startups Founders Hub Becoming a founder is no longer about who you know. You'll have access to their mentorship network, giving you a pool of hundreds of mentors across a range of disciplines and areas like idea validation, fundraising, management and coaching, sales and marketing, as well as specific technical stress points. You'll be able to book a one on one meeting with the mentors, many of whom are former founders themselves. Make your idea a reality today with the critical support you'll get from Founder Hub. To join the program, just visit Talkpython. Fm/foundershub. All One Word the links in your show Notes thank you to Microsoft for supporting the show.
I want to preface this by saying, I'm not a lawyer, I'm only speculating here. But one of the things that seems very much like it fell through the cracks and this part, I think is both maliciousness and laziness on the worth IT company, as well as sort of either laziness or disinterest, I guess, from git hub. I don't really know how to characterize it, but this company came and said on your documentation there is content that is copied. Right. And it comes from our website and it just linked just to the homepage of that other website. You got to take it down. That seems like insufficient information or GitHub to go. Yeah, well, they said there's a website and here's a website. That website doesn't like this one. So it should go away. It should say, do you see these lines of code here that was stolen from us and here's where it originates or our thing is not public. But these are the laws. They didn't even say what was wrong.
Right.
It just said it was sufficient.
Even for us, if it was an accurate claim. Because if you look at this page that they put the claim on, it's a huge page because it's got like about a dozen different functions on it.
And it just said that they copied our examples. It didn't say which part of the page was copied or anything. But I still don't know how they even decided that this was a thing that somehow their automation got flagged incorrectly or something. I don't know.
I don't know if we're ever going to know that. Yes.
Well, I don't want to spend the whole time on this, but let me wrap it up with a quick thought.
The CEO of Hacker Rank Vivek posted a message that said this was not our intended consequence. Yes, but if you send bots running around the Internet looking for algebraic equations and saying that those are like this is your problem, even if it was not your intent to do these things.
And so they fixed it. I don't know what they're doing now, but they said we're going to stop the whole process for now and figure out what we can do better. But on the other hand, we should give them props for donating $25,000 to the SymPy project as a we're sorry, that's actually kind of cool. They didn't have to do that.
No, they did not have to do that.
And they did send the money. I think last week you guys are on vacation.
What is this, Hawaii or I'm just teased.
If the finances are online, you can find them up. I think it's open collective and it pretty much almost doubles our budget. And so it will allow us to really find all kinds of good development. One thing on this note, I wanted to say that I was thinking so when it all started, I thought I felt like a little guy completely being crushed by some huge corporation or just this, you know, they just take down the documentation and get help. Just as you know it's not enough to put a commit to fix it. You have to excite the commit from the git history.
So we would have to figure out exactly what line was copied. So I went to the gate history and tried to look at well maybe some of our contributors maybe copied some stuff from Acreage as well. So I went to the history but didn't see anything, did not see any mention of accuracy or I copied this from Acreage, didn't see anything like that. They didn't see anything suspicious but the consequence was there. And also the documentation is generated from the sympy source code. So really the offending lines are coming from the SymPy poster itself, not just the documentation.
So they will go but luckily they missed it.
I was like well this might be this is terrible.
And also we thought maybe this looks like a spam, maybe it's just a spam. So we kind of ignored it a little bit. Not ignored it, but we didn't know. And so I emailed GitHub right away, is this real or is this just a spam? And they got back to us on Monday evening and said no, this is real. And the next morning they took out the whole documentation. So I felt really just so many hours just trying to figure out what we should do and what the options.
Google Summer of course was deadline was on that Tuesday I think as well. So I was just super busy with that. I just felt and I'm doing this for free, for simple. I don't think I've ever paid by anybody to work on SimPy. I just felt this is not right. And then when I got to Hacker News I thought, I thought about how can the company, what can they do to fix it? And I said how much they can do the downboards wasted. But then travis got an idea or if I got an idea about what they donate some money and I thought, you know, this would fix it. I didn't think they would do that, but I'm very happy that they did. As far as our concern personally, I think we are even they give us the money and we can use it to really progress the development forward. So I'm very happy that how it all ended for SymPy
Sure you could pay to hire somebody to work on some important part or you could pay to have Sprints like bring the people together to work together or something like that, right?
Yeah, we're still talking about what we're going to do.
Cool.
Well I'm glad it came out well but what a wild story.
I've had run ins like this before and they are incredibly frustrating even when you're on the right side of it. It's just like you're up against lawyers from yes, you're on YouTube.
So I've heard that DMCA is going to be pretty bad on YouTube. I don't know if you've ever been hit by anything like that there.
You know what's so funny is only once, as it happened on YouTube, it's happened for my courses.
It's not exactly. It's happened sort of almost in reverse for my courses. I put one of my free courses on Udemy as a way to try to reach out to people who didn't already know about my content. Like I'll put it up there for free.
People can experience it there and then maybe they'll go look for other courses for me, something like that. Someone stole my free course, started selling it on Udemy, and it took me two weeks to get them to even take it down, even though at the beginning it's a picture of me saying, Hi, I'm Michael and we don't believe this is yours. What do you mean?
Have you watched it?
The person whose account is under is absolutely clearly not Michael. Anyway, on YouTube, what has happened to me is I was doing a webcast way back in the day when people would call in sometimes on phones and somebody interrupted someone else during the webcast and they put it on hold. And it was really frustrating because their hold music started playing back into the webcast. And for some reason, the way it was set up by the company I was working with to do it, they couldn't stop it. So there was just like five minutes of hold music going along with the presentation that Hold Music got a DMCA takedown and it took down my webcast.
So what are you going to do?
I didn't really mind. It was the kind of a crappy thing anyway, but it was up there and it got taken down. Alright, let's talk about SymPy because I think this is a really neat project. Like I said, when I think about the data science stack and the scientific computing stack of Python, traditionally what I've thought of is NumPy pandas mat plotlib the stuff that does numerical processing, and then maybe virtualizes that, or is machine learning off of it or something like that. But SymPy, I think occupies a slightly different but really important space in this whole computational Python stuff about it.
Yeah. So SymPy. Like you said, it sort of stands in contrast to these other libraries in that it is a mathematics library, but it's not numerical, it's symbolic. So the focus is on computing with mathematical expressions. Exactly.
So if you tell SymPy to like you said earlier, solve the equation X squared minus two equals zero, you'll get the exact answer, square root of two, minus square root of two, you won't get a numerical answer like 0.7, whatever square root of two is. Yeah, but you'll get that exactly. Square root of two.
And so there's all sorts of things that you can do with symbolic mathematics.
People may be familiar with other similar tools.
Basically, it's called the computer algebra system.
There's proprietary tools like Maple and Mathematica. There are some other open source systems that people may have used as well, like Sage and Maxima.
So just if you've ever heard of any of those, SymPy sort of occupy a similar space. But SymPy, I guess, sort of stands apart from those in that it's open source and it's a Python library. So if you're familiar at all with Python, it's really easy to start using SymPy because it's just Python.
Yeah.
I think people who have not seen this kind of stuff in action should definitely go poke around and check it out. And we'll talk about some ways in which you can play with it just online with super low effort. I remember the first time I had been previously using MATLAB or something like that, and I saw Maple, which is one of the ones you called out, which is a symbolic sort of solving thing. You can say, oh, here I want to do the integral from negative Infinity to positive Infinity of this thing. And it looks like it would come out of the textbook and it will sometimes even show you the steps. It's unbelievable. And that was 20 years ago when I saw it. I'm like that's unbelievable that this computer is doing this. And SymPy is like that for Python, which is fantastic.
Yeah. So it's basically the math that you would learn in a classroom, except it can also get very advanced. Like you said, we can do integrals. We have lots of very advanced mathematical features.
We have a module for doing various areas of physics, for example.
Nice. And it's also the foundation of many other things as well. Just as setting the stage, a preview is you've got algebra, you've got calculus, you've got differential equations, you've got linear algebra and matrices. There's a lot of good stuff in here. Andre, do you want to maybe give us a little run through of sort of the selling points of SymPy?
Yeah, that's very easy. I was an undergrad student and study physics or any kind of engineering. A lot of times, even math. You have to do a lot of symbolic, I would say derivations on paper. And I remember sitting in a physics class and I thought I would like to do this from Python Interactively.
I thought that's the idea. And then of course, I sat down and I thought, well, let's get started. And my friends were telling me, can I do Gaussian integral? It's this integral of exponential X class, for example. And I said, you know, it cannot because it will in five years, just not now.
That's the hard problem.
And I said, well, I use Mathematica. It's going to be now.
But they asked me, well, why don't you use Mathematica? And I said, you know, Mathematica is great.
Maple as well. As you said, Michael, absolutely amazing. That 20 years ago, and it could do all this integral and series expansion of these functions.
I was using Windows Nt when I did that.
I thought that was actually but the motivation is to be able to throw by Tone interactively allows you to kind of almost program with the Symbolics using a language that's a pretty decent language that you might already use for something else. And so what I wanted to do is assign the expression to a variable, then use the variable directively and write some scripts to kind of handle my calculation and maybe save it to a file after that, and so on.
Once you want to program with that mathematical, it allows you to program, but you have to learn that language.
I like Python more than the mathematical language, and so that's why I wanted to have that in Python.
Well, the other thing that from this perspective, sitting on the Python or the comp side side of things and looking back is obvious. I don't know that it is as obvious coming from the other perspective of like, oh, I'm doing a MATLAB in File or whatever. But in that world, if you work in MATLAB or Mathematica, you can do what MATLAB or Mathematica does. Right.
It's really amazing in its specialty, but it's very specialized and limited. Right. You can't build like fast API database driven apps that are doing some of this kind of computation along the way. Right.
If you move it to Python, this capability is now accessible for all the applications, not just within the MATLAB or Maple environment.
Yeah.
And I guess it's an argument. What's the advantage of Python, let's say, for numerical computing, let's use, let's say, for scientific computing. What's the advantage of Python over, let's say, Mathematica? And I think it's not a clear answer. I think Mathematica is great and they've done actually. It's quite amazing how good job they've done because they design the language, I believe, in the early 80s, and they did not have to really modify the language too much.
In the same spirit. So that's kind of amazing. It's much older than Python, so it's quite amazing how far and then it still works pretty well. And it's a decent language. But I think what I like about Python for scientific computing is that it's open source and it's the language seems more kind of robust. It's going to be easier, more impressive. Don't have to really learn too much. It seems that anybody can learn it quickly and doesn't seem to have too many kind of things that would surprise you.
Yeah, very cool. So how long ago did you start on SymPy?
I think I started it in 2005 or six.
Nice. It's been going for a while.
Yes.
That really predates a lot of the scientific computing frameworks that are well known today. Right. So you must have felt good about picking the right horse. As you saw Jupyter or IPython at the time come along and libraries like that.
Way before Jupyter, I Python was there.
Somebody told me about it and I tested it out. This is pretty cool. Looks like Matt miracle. Then later when I talked to Fernando, who wrote it Mathematica. That's what I wanted to have in Python. So kind of the same motivation, almost just so. He kind of provided the foundation for the interactive parts with the prompt and the numbers.
This portion of Talk Python to Me is brought to you by Sentry. How would you like to remove a little stress from your life? Do you worry that users may be encountering errors, slowdowns or crashes with your app right now? Would you even know it until they sent you that support email? How much better would it be to have the error or performance details immediately sent to you, including the call stack and values of local variables and the active user recorded in the report? With Sentry? This is not only possible, it's simple. In fact, we use Sentry on all the Talk Python web properties. We've actually fixed a bug triggered by a user and had the upgrade ready to roll out as we got the support email. That was a great email to write back. Hey, we already saw your error and have already rolled out the fix. Imagine their surprise, surprise and delight your users. Create your Sentry account at talkpython.fm Sentry and if you sign up with the code Talkpython all one word. It's good for two free months of Sentries business plan, which will give you up to 20 times as many monthly events as well as other features. Create better software, delight your users, and support the podcast. Visit talkpython.fm/sentry and use the coupon code talkpython.
When you work with SymPy, we'll see some examples and talk about them in a minute. You can put it into this pretty printing mode where it attempts with as much as it can within the terminal output to have more formal mathematical representation. So instead of like E carat X, it might put a little smaller X up high and then an E down slightly to the lower left of it like you would try to write it. It seems that if it's in a notebook, it should be able to do even better, like maybe a Latek rendering or something really shiny.
Yeah, it does. In the notebook. It'll use the math checks.
It'll look great, basically because the math checks look just like it's the same as the logic document.
Yeah.
In the terminal we use all these different Unicode characters to sort of render it as 2D text in the terminal so that it looks pretty decent in the terminal considering the constraints of the terminal.
And I personally use it. I mainly use it in the terminal. I sell it.
Yeah.
So let's go and maybe we could walk through a little bit on one of the tutorials here.
Obviously we don't want to talk too much code or whatever. But I do think maybe just touching on this will give people a sense of what it's like to work with this because give us a sense of what in the tutorial.
There's actually a section somewhere but didn't get deleted.
It's in the introduction page. Yeah. It's on that page. But if you maybe scroll down to The Power of Symbolic Computation is the name of the header.
There you go.
So this is just sort of a bucket list of just sort of a bunch of different examples of things that can do. So just to give you an idea. And actually you can see there also you can also see the pretty printing there as well, the Unicode pretty printing that it does.
Use.
Unicode equals true, right. It doesn't do it by default.
In the notebook. It does actually do it by default, sure.
But not in the terminal or the reply.
Yeah, in the terminal you need to run this. Otherwise it'll just print out like a one dimensional string that you would get.
It looks sort of like what you would input, but yeah, you can see here, it can take derivatives, take integrals.
If you keep scrolling down, you can see, I think, limits and differential equations.
Yeah. Let me talk people through just a couple of things because I think it's a little hard to understand how this might work. And the trick I think really Andre, tell me your thoughts on this is the ability for it to define these symbols in these functions here. Yeah.
So the trick is able to represent the expression symbolically. So you type X plus Y plus some function sign X. And in memory it represents it as a tree and it follows the expression in symbolic form. And then it has all kinds of functionality. It allows you to manipulate the expression, print it, differentiate it when you differentiate, let's say an expression that takes the original expression and creates a new expression, the derivative.
Right. With normal math like pen and paper math, you don't usually define variables. Every now and then you say let X be an element of the real numbers such that whatever. But normally you just say F of X or F of T or something like that, or Y. And it just works. You needed some way in Python to allow you to write expressions like X plus two Y without Python going, I have no idea what that means, right?
Yes, that's right. And the SEO first has to declare what X and Y is. You declare it as a symbol and then you can use it to be override the Python operations like plus financing. That way you can construct the expression. And so what's nice about Python is that when I started it SymPy, I was kind of investigating the idea. What's nice that Python pretty much allows you to override all these operations so you can write it almost like math differentiation, two stars. Yeah. Only caveat is that if you write, let's say one divided by two and we started in Python two, that gives you zero. I believe that's very confusing from SymPy perspective because we would like it to give the expression one over two, not normal.
I don't think there is any way still until to fix that to override this division.
At least in Python three.
You get the right at least you can double precision.
You don't want that. You want one divided by two. Simple expression.
So when you have something like that, you have to wrap the number one.
Yeah. Or define some kind of symbol with that value and then use it like you have to go from quadratic equation. Right.
That kind of thing.
But yeah. So you create these symbols and then you can write simple math that looks like it's just straight Python. So you could say X and Y are symbols, and then you could say something like X plus two times Y plus one. And that isn't not evaluated in any way. It just becomes this, as you said, this tree, this expression that you can operate on, like integrate it, take the derivative of it, find the limit of it, all those kinds of things. Right?
Yes, exactly.
That's the basic idea.
And you can use it to do basically any sort of math that you would normally do with that sort of expression, except you're doing it on the computer.
You can do just like a real simple example might be rational polynomials or something like that. Like if you had X squared minus one as one equation and then X plus one as another equation, you could say the first equation divided by the second and get you get X minus one.
Yes. Simplification is another one where you can take something and it can figure out how to simplify it to an equivalent form that's like dividing out factors and things like that. Yeah.
Okay.
These are super neat. You can do factors. So like you say, you could say like polymal factors. You know, one of the things I don't know if I should point this out or maybe this should have been a warning to the whole show.
If you're in high school or early College, this might be a terrible cheat sheet for homework and other types of it's fantastic. Right. If you're in an algebra course, you can do your work and then you can type this in and go, did I get it right? Wham. And it comes especially in a notebook, right?
Yeah. I mean, I think that's kind of unavoidable these days because there's also just graphing calculators that do this. There's Work from Alpha, I think simply is a great way to do that if you're going to do it, because now you're also learning Python, which I think would be great for someone who's like a high school student or an undergraduate because that's an actual useful skill as well.
It might be even more utilitarian in the long run than the calculus they're learning.
You can do like derivatives and integral of these equations. So you could say integrate e to the X times sine of X plus e to the X times cosine of X. And it will give you the result, which apparently is e to the X sin of X. I used to be able to do that. I can't anymore.
Well, you can see the line above it. It's differentiating that. So it's just undoing the line above it.
Oh, I see all that is a bit of a cheat, isn't it?
The integration is nice because you don't have to remember how to do all this integration by parts or whatever you do.
Exactly.
So another thing it can do is like concrete. I forgot there's a better term for that. But integration over a range, you could say integrate from negative ten to 20 of sin of X squared. Or here's an example of negative Infinity to positive Infinity. And it says that square root of two radical two, radical Pi over two as the answer. Not like point. What is that point to something? I don't know. Something like that.
Right. It gives you the actual theoretical answer, the exact mathematical answer in symbols, which is amazing.
It's amazing. And it's also not easy to. So when I started, I knew this is not easy to program. How do you program such an integrator? It's not easy. But I figured if I can at least get the basics like be able to represent these equations, at least that will still be a huge help because sometimes the expression can be long and be able to manipulate it. And then as we were joined with so many excellent people, they contributed all the feature students mostly actually was developed by Google number of code students.
Okay.
I would not be able to do that. We just put it that way. It's a little work that's behind it.
Yeah, I'm looking at this. I know these concepts just on pure math are hard. And then to automate it in general, it's got to be next level.
So other things you can do is you can define a function. So you say, here's a function called Why? And then you can say, well, what if you had the differential equation that was the second derivative of y minus y equals e to the T?
Solve that and then sure enough, outcomes the solution for that what the function is, which is pretty amazing. Yeah. So does things like Eigen values from linear algebra and all kinds of stuff.
Great.
And then we have in Python, we have Stir and Repper. You guys also have latex, which is pretty cool. I just call latex latex on a function and out it comes with like the crazy escape code latex that you would need for a paper or something. Right.
Yup. Yeah. This actually I mean, this is only even scratching the surface of the SymPy I can do. So it's actually quite a large library.
Yeah. I don't want to focus too much on just the pure math, but maybe give us a sense of, like, some of the things that amaze you. What do you have in mind when you're saying that kind of stuff?
That amazed me.
Yeah.
I think the whole thing is amazing still, even though I know how it works and I've been working on it for a while. But just the fact that the computer can do the same sort of mathematics that you would do on a piece of paper is incredible.
Some of the algorithms to do, like integration and stuff are also pretty interesting because they go beyond what you would learn in a calculus class.
There are algorithms that can compute integrals that you would never be able to know how to compute them just using what you learn in a calc one or calc two.
Sure.
But those is something that you can actually implement in something like SymPy, and then Sympy will be able to do those integrals for you.
Some of the features that if you go on the website, there's a huge list of features.
I think one feature that we didn't mention that's maybe worth mentioning is code generation.
So code generation means that you take one of these expressions and you turn it into basically code for another language, whether that's C or Fortran or pretty much any language that you would want to translate it into. And then you can then take that expression and basically convert it into something that you can numerically evaluate very fast in whatever language you prefer to use.
Okay. So you've got your notebook written in Python or something. You've come up with some expressions and you're like, I would like to just do that in Fortran or C, and I don't trust myself to get it right. So just print out the syntax, basically.
Yeah, go ahead, Andre.
Yeah. Let's say you want to approximate some function with the polynomial so you can use SymPy to do that. And then at the end you just want the polynomial in the form that you can put in your production code, whether fortran or C. So simply to do it, then you can copy and paste it. You know, it's correct, assuming there is no backing SymPy.
Yeah, sure.
I suspect it's probably pretty straightforward once you've got the expression to break it down into. This is a multiply here's where the parentheses that group it in the expression tree. But it's not simple.
There's a few places where it's like, okay, we need to make sure we get the semantics. The semantics might be a little different between C and Python or something like that.
So we need to make sure we sort of translate that correctly. But yeah, in principle, it's not that hard, but it's also not something you want to do by hand either.
Because it's super air prone if you were to try to do it by hand. Yeah, it sounds like a great feature. That's quite neat.
Maybe we could talk just a little bit internally, Andre, about how you accomplish this. Yeah.
Like how I started it.
Well, how does it work if I give it an expression of e to the X, cosine X, and I say integrate that, where do you even start? Yeah, exactly.
Well, the integration, I don't know what he does is like a couple of different algorithms, but I'll tell you kind of the basic idea.
The first thing you do your search, how do you do symbolic integration?
There is the famous algorithm called algorithm. So you kind of start studying and then you realize that it's like multiple years of work to work to implement this. And it's kind of fragile and doesn't always work. And mathematical, as the company, they manage to do that, that's a lot of effort, a lot of work, and they have to invest in large teams of people tested carefully and so on. But in some way, in practice, there are other approaches, and it turns out that you can integrate wide glasses of functions just by implementing, for example, for a polynomial, it's easy to do it right. And then you can add some trigonometric functions. So you kind of implement algorithm for that. Then you can't build your way up. It turns out when you do that, you can make it very useful in practice. Maybe it's not as powerful as Mathematica is, but it's very helpful. So that's how we started.
And then once you have the rules, 1st, 2nd, 3rd year of calculus in math, there is a ton of creativity in the calculus classes. It's a lot of like today we're doing integration by parts. Today we're doing like integration of stuff that's divided or whatever. There's certain algorithms that they tell you to follow. And once you get the basics, it seems like I guess you could compose them.
Yeah. So that was kind of my initial idea. Let's just do stuff that we know how to do and it's going to work.
But then the engineering part can do it as well because you want things to always work quickly. And if it cannot be done, you would like to know the answer. This cannot be done quickly, not to wait a couple of hours until it tries all the phone calls. And so then it just becomes a lot of engineering decisions how to make this all work. And I think we are still not done yet. I think there are a couple, I would say promising approaches. One approach is a certain professor, and I think a retired Professor, I think in Canada, he figured out how to take all these rules, how to integrate functions and compose them into just a decision tree. So you give it an expression, and then it just figures out exactly as you said, is it the polynomial? Is it like dividing and so on.
And then the decision tree tells it exactly how to go about it to give you the final formula. Okay, here's the small formula you apply to it or whatever these 5000 formulas and then takes them and actually uses Mathematica and he composes those into a decision tree. And then it prints the decision tree as, for example, Python code and so on. And we still have well, actually. So we have a module for that. And it's something that what I like about this approach is that it's quick in principle. It's quick. You just go through the decision tree and it gives you a formula or it says it cannot be done.
But there are all kinds of practical issues. The tree is. And so when you call it in Python, it takes forever to import and so on. So you're still kind of struggling with these issues, but it just gives you an idea what kind of issues are engineering, I would say issues are involved in?
Yeah.
Have you thought of or using things like Cython or these other types of speed up type things? Yes.
So maybe ten years ago, I spent a lot of time investigating how to make Simpy faster. Sympy is great, pure Python. It's easy to contribute to, and for many things it's amazing. Just works. And that's all you need. But sometimes you need either larger calculation or a lot of calculations and it's not fast enough. So how to speed it up? So we investigated just pure C Python, all kinds of tricks in Python itself to speed it up. Eventually that kind of led to the same engine project. I decided, let's just use C++. It's the only tool that I know that actually can deliver the benefits and kind of maintaining a bigger project that's imagined. And we have Python wrappers and then SymPy can use it. So there's modules in SymPy, such as the dynamic, the classical mechanical, I guess module that allows you to simulate solid body physics.
It's able to simulate. So it gets much faster.
Okay.
Interesting. Yeah. So this is a C project, but it has Python wrappers for easy Python integration with Sympy. Other things, it's cool.
I think that kind of summarizes a lot of scientific Python.
There's a really great API, and when you ask it to do things, it takes the data and hands it off to some see layer that actually does it or Rust or something like that, right?
Yes.
And it's not just writing it in C++. There are other libraries, but also in C++. But to make it really fast, one has to spend the time and figure out how to represent the expression in memory, how to allocate the memory.
So we have to make reference county pointers, for example.
That's the design I chose.
How to make the reference got to point you as fast as possible, things like that. I have to make sure that you can actually maintain it so that if you make a mistake it doesn't give you a sick fault or some kind of an independent.
I ask you to solve this and it went proof and went away. I guess that means something.
The symbiji works.
It's kind of like the level of the core of simply if I go Pip install Senpai, do I get this or do I have to do something special to swap out the computation engine with this?
You have to install it as a separate library. So if you do just PIP install Sympy by default it only installs Sympy.
I think you can do Pip install simulator. I use Conda, so you can do Conda install symengine that installs imagine as a library. And in Python you do import Symengine and then you use it kind of like Sympy, and Sympy can also optionally use it kind of one to build.
Okay. Yeah, this looks really neat.
One of the things I wanted to touch on here and at the top right of the page, if I go just to the SymPy page that says try it with Sympy Gamma. And so maybe we could sort of close out the conversation a bit. Was just poking around with this and then maybe highlighting some projects that use it. So for example, it says oh, you could just try some random example and it's got like algebra algebraic things I could do. So it says polynomial divisor. I can come in and copy this and if I go a little calculator like thing at the top where I go hit equals and it will go and run that in people alpha division.
In this case it looks like.
Yes. Like what are the divisors of this thing, right. Something like that.
Yeah. So this is sort of our little version of Wolfram Alpha, but using SymPy under the hood, it's not quite as powerful as Wolfram Alpha. We don't support like natural language input, that sort of thing. But yeah, you can kind of get an idea of sorts of things simply can do here.
Maybe one of the interesting ones if you scroll down a little bit and click on one of the integral, the one that says get steps or integrals. Yeah.
How about this? I'm a big fan of E. There's a whole book called E, The Story of Number. Have you guys read it?
No, I haven't heard of that.
E The Story of Number is a great book. It's about like Euler and all that stuff. Okay.
E to the X over one plus E to the two X, right.
Yeah. So if you scroll down here, hopefully you should see something that says see steps under the derivative, for example.
Yeah, that was pretty interesting. I don't know if this is the one that has steps, but I saw it in other places.
Yeah. Maybe those examples is not working right now.
Yeah, there's some here. Let's do probably the differentiation of something might be I bet it's got some steps for that. But that was part of what I was talking about with the cheap. And I don't mean that in a negative way, but it will show you the steps as if it was written out in a textbook of how like this one right here, look at this. You're going to apply the quotient rule, which is DX of F of X over G of X equals this, and then you're going to apply this.
This is amazing.
Yeah. Well, I think it's instructive. It's not just cheating.
No, of course it's not. And I do think it's really instructive because it's one thing to just go take a function or an expression and say take the derivative of this, and it says, great. It's this crazy thing. Like how was I supposed to know it was like the Tan of the co tangent of X or something like that. Right.
But if it says, look, here's how we got there.
That's very educational.
Yeah.
Many parts of SymPy don't work like this because the underlying algorithms don't really work the same way that you would do it by hand. But there are some that basically work the same way you would do it by hand, like differentiation as an example. So we can sort of extract those steps and show them to you.
Yeah, this is great. I'll put this explanation example into the show notes so people can come back and check it out. But Gamma Sympy.org and then just use some of the examples is really how to do it.
So very nice.
Let's wrap this up by going to Sympy.org and then on Sempi.org, if you go just down a little bit, there's projects using Simpy that are they all sound super interesting to me. We've got like Kenpai, a package for chemistry in Python, EinsteinPy for symbolic, and for general relativity.
Are there any of these that you think are particular need or stand out to? You want to give a shout out to either of you? Oh, yeah, all of them.
But I like the PyDy, for example. It's a very nice package for you can pie dies and dynamics.
So it allows you to simulate kind of like a robot or pendulum, like double pendulum. You just kind of tell it exactly the relationship of the body, and then it allows you to write and then PyDy can derive the equations of motion and those equations because it can get extremely complicated real quick.
Try triple pendulum, which is very complicated by die can derive the equations for you correctly.
It's a neat project. Yeah.
That one's really cool.
The Chempy kind of stands out for me because I've always loved chemistry.
Any others that you want to give a shout out, too?
Well, I guess one that I mentioned here. Actually, it's listed as Sage. So Sage.
Sage is something that a lot of people might know as sort of an alternative computer algebra system.
Yeah.
I've actually had Williamstein on the show to talk about it as well from Sage Math.
And Sage integrates a lot of libraries, including Simpa itself. You can see SymPy is listed there on the front page of their website.
So if you use Sage, there's a chance that you're actually just using SymPy under the hood.
That's one that I like.
A lot of these are making use of that quantum concept that I talked about where they're basically sort of modeling whatever chemistry or dynamics and instant pie, and then taking that expression and turning it into something that they can numerically evaluate.
Yeah. It looks like maybe some quantum computing stuff here. All right, great. Now these are all cool, and I think probably seeing some uses of it, giving people ideas for their own projects. Let's wrap this up, this conversation up. Just talk about maybe bridging the gap or bridging the world of computational stuff, symbolic stuff, and then this numerical side. Right. So I've gone through and I said, here's some complex function, and maybe here's another one, and I'm going to combine them through whatever in some way, and then now generate me a second derivative or whatever it is I need to integrate it. I've now got a new expression. Can I somehow take that and turn it into something I can call as a Python function? Like here's a number, what's the answer effectively? Or here's a NumPy array. Give me the evaluation across the NumPy array.
Yeah. So there's a function called Lambdafy, L-A-M-B-D-A-F-Y which basically does exactly what you said. It takes an expression and it turns it into a function that you can evaluate with NumPy.
So, yeah, the workflow is basically exactly what you described. You use SymPy, derive whatever it is you're doing using the mathematics of your problem, and then you put that inside Lambda fy, and now you have something that you can actually pass your data to with NumPy and evaluate it numerically.
Nice. That's awesome. Does it effectively use that third generation thing you're talking about?
Yeah.
So under the hood, it's basically generating code for language equals.
Okay.
Yeah.
I mean, you can think of NumPy itself as sort of a language. It's got its own set of functions.
Right. Instead of looping, you do sort of vector operations and things like that which you'd want it to do. That.
Yes.
There are other functions which you can do instead of calling NumPy if you want to call it through C as well. There's options for that as well.
But yeah, that Lambdafy is sort of the big one that you need to know if you want to do that.
Okay.
Because to me, that seems like a really important bridge. I've got this idea here's my theoretical equations, but at some point I want to evaluate it and make the computer generate a graph based on these numbers or something. Right?
Yeah, definitely.
Oh, well, good work on this project, you guys.
It's pretty amazing.
The explanation thing, Aaron, you had to pull out. That's really cool how much it will say these are the algorithms we applied. And here's the little lesson to take from why this makes sense here and so on. That's way better than just some sort of numerical integral like you gave me this function and it's 7.2 is the answer. Great. But what do I do with that? Right.
Yeah.
So maybe people could use it as a teaching tool, assuming.
Yeah, there are people who use it in the classroom. Definitely.
Sure. Yeah. All right. Well, before we're done, let me ask you both the final two questions briefly, if you've got some kind of notable package, maybe it's not the most popular thing, but, you know, some Python package that's awesome. That needs a shout out.
Probably a lot on this page already and you've already given some. But anything you want to just call out real quick?
Well, perhaps unrelated to SymPy a little bit.
Yeah, it can be unrelated. Anything.
Yeah.
Well, I'd have to say one of my favorite packages that I use is this testing library called Hypothesis.
I'd actually like to make use of it in SymPy. We aren't using it right now, but I'd like to. But if you haven't used it before, it sort of flips the idea of how you do tests on its head a little bit.
Instead of coming up with a bunch of examples and sort of testing that your function does the right thing on different inputs, you just sort of tell it what your function should do, and then it takes care of the job of generating examples. And the end result is that you end up testing a lot more of your code than you would with a normal test, and you end up with much more robust code as a result. So I recommend checking it out. It's called Hypothesis. I don't know if you've had Hypothesis on this podcast.
I have. It's been quite a while. It's been three or four years at least. But yeah, it's a very neat project, and I'm glad to see it's still going strong. I hear a lot about it. Andre.
Do you want a Python package or any package?
Python if you got one. If not, we can fall back to any.
Yeah, I was going to actually Hypothesis also, I also discovered it kind of actually relatively recently.
Yes. I recommend people to check it out. Which one? Sorry, the hypothesis.
Oh, yeah, sure. I did talk about it way back in the day. This is 2016.
Had David Mackeyr on to talk about it. So that was cool. All right. And then final question, if you're going to write some code. The Python code.
What editor do you use?
I use Emacs.
Emacs right on.
And I use Vim.
And you guys still get along?
Yeah, of course.
Not just easy.
That's awesome. All right. Well, thanks so much for being here. Final call action. People are excited to get started with SymPy. What do they do? How do they get started? Where do they go?
Well, the easiest way is if you go to SymPy.org, like you said, you can try it online.
There's also a link there to download it.
Yeah. Otherwise, I would say if you really want to dive in, you can join our mailing list or you can follow us on Twitter. We're at SymPy and basically the easiest way to get it is just Pip install Sympy or condo install Senpai and you'll have it nice, Andre.
Yeah.
Sympy.org Simaging or you know like the C++ version.
Nice. And you have the tutorials that are highlighted. I'll link in the show notes that you can go through on Sympy.org as well. Fantastic. Well, really nice work.
I love to see you bringing this to all the developers and data scientists and stuff. So thanks for being here. And Sharon Senpai, thank you for everything else.
You bet. Yeah. Thank you so much.
This has been another episode of Talk Python to me. Thank you to our sponsors. Be sure to check out what they're offering. It really helps support the show.
Starting a business is hard. Microsoft for Startups Founders Hub provides all founders at any stage with free resources and connections to solve startup challenges. Apply for Free today at Talkython. Fm. Foundershub, take some stress out of your life. Get notified immediately about errors and performance issues in your web or mobile applications with Sentry. Just visit talkpython.Fm/Sentry and get started for free. And be sure to use the promo code talkpython all one word when you level up your Python we have one of the largest catalogs of Python video courses over at Talk. Python. Our content ranges from true beginners to deeply advanced topics like memory and async. And best of all, there's not a subscription in site. Check it out for yourself at Training.python.fm be sure to subscribe to the show, open your favorite podcast app and search for Python. We should be right at the top. You can also find the itunes feed at /itunes, the GooglePlay feed at /Play, and the Direct rss feed at /rss on talk python FM.
We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.Fm/Youtube this is your host, Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and write some Python code.
