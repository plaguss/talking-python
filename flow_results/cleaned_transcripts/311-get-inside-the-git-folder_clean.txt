These days Git is synonymous with source control itself. Rare are the current debates of whether to use 'Git' vs 'SVN' vs some 'Fossil' like 'Source Safe' vs 'you name it'. But do you know how Git works? What about its internals, I'm sure you've seen a .git folder in your projects route. But to most folks, that's a black box. In this episode, you'll meet Rob Richardson. He's going to pop the lid on that black box as we dive into Git internals in the 'Docket folder', among other things about 'Source control'. This is talk Python to me, Episode 311, recorded April 1 2021.
Rob, welcome to talk Python me. So glad to be here. I'm really excited that I get to join you. Great to meet your audience. Yeah, it's great to have you here. You got to meet intersection, you gave a talk at the Python web conference recently that also spoke at and your talk was really interesting, and certainly relevant to the Python, folks. So I thought it'd be cool to have you over here. And, you know, I should give credit to Paul Everett for connecting us he's like, Oh, that was a great talk. You should go talk to Rob. So thanks, Paul, as well, who's not long ago on the show? Yeah. I've been chatting with Paul about thoughts around the talk as well. He's a really brilliant guy. Yeah, he is. He definitely is. He's been doing a lot of cool stuff for a long time. So yeah, he's a great guy. Now, before we get into 'Git', and all those types of things, which, you know, it's really surprising to me how much it's taken over the world, right used to be, there was always a question, well, what 'Source Control' do you use? Like, that's not a question I hear all that often these days, not at least as much as it used to be. But before we dive into the details of that, let's start with the story. How did you get into programming, this is actually a really fun story. I was 10, I was at the library, because they had the computer. And we'd play video games. And the methodology of how you do this is you go up to the counter, and you flip through the book and you go find the video game and you show them that page, and they give you the disk and you hit the save icon, you take the save icon and you put it in the computer, you play the game. So I had finished playing my game. And I went back to the desk to go picking another one flipping through the you know, plastic sheets, and I found a drawing program. And we said that I'd like to play this game, they gave me an eight and a half by 11 sheet of paper, the top two thirds was graph paper, you know, graphs. And the bottom third was how to write the program to draw that on screen. Oh, cool. Okay, and it was so much fun, I got to start to build content that was in my mind, in real life in this artistic medium with a very technical implementation. So you know, that was so much fun. I didn't ever return that game. And so that kind of brought me into the world of software development. I always thought it was just a fun thing that people did. I didn't realize it was a career. So it wasn't until really late in my college experience, where I realized that I could do this for a career. And so after I graduated, I got into programming professionally. And I've had a really fun time coding now for professionally for more than 20 years. Yeah, awesome. I think programming is special, because it's one of those things you kind of hinted at where you, you think of something, you dream, something, you imagined something. And then with a little bit more thinking that thing can become real. Whereas you know, so much of what humans do, it's one or the other, I could tell an amazing story and write the book. Or I could go build an awesome house. But normally those things don't actually co exist where you think a lot about something and they they come into existence. But I do think that's a magical part of what we get to do. And I think it captures a lot of people's imagination. And what's really cool is that in this digital world, there are a lot less boundaries, a lot less constraints. There's nothing telling me that this pixel needs to be in this certain way. I can draw whatever I want on these pixels on the screen. Yeah, yeah. And modern day we have cloud computing, and we have incredible computers. Like the sky's the limit is really, really awesome. Also money. You don't have to go buy tons of hardware for many things that we do, right? The really cool right now, how about today? What do you have to these days, I'm doing a lot with software development, 'Cloud' based development, a lot of websites, a lot of Web properties, 'ASP. net' and 'Node' on the back end, 'React' and
had to play with Raspberry Pi's. And that's really fun. And getting to dig into all the things, I've gotten really good at doing DevOps as well, part of my passion is being able to share this knowledge with others. So I do a lot with teaching both at user groups and conferences and elsewhere mentoring. And so it's really fun to be able to not only learn these new skills, but also pass it on to the next generation of developers too. I'd love to say that. It's not that I'm really good at it. It's just that I've been collecting things for a while. So let me add to your collection too. Well, I think one of the things that's really interesting about becoming an expert in programming, people who are beginners or maybe don't do programming at all, they see that person as incredibly talented and incredibly smart. And they may be they often are, but I feel like the the real big difference is, I've spent 10 years gathering up these little tips like, Oh, I tried this, that doesn't work very well, that crashes, you try to talk to the database that way. That's bad. Oh, by the way, I've also built up a couple of examples of what databases are. And I've seen, you just have this almost more experience than I don't know, like, innate skill, right? So it's really cool that you just kind of layer on these skills over your career. And the reason I think that's powerful is it's very easy to communicate back to other people, right? If you know, the way 'Nietzsche' did 'Philosophy' or the way 'Euler' did 'Math', like, you can't, or Bach did music, like you can't easily communicate that to someone, if it's this crazy innate skill, you can sort of communicate it, but it's not the same. But with programming, I think it's very easy to transmit it on and pass it on, and ways to help people like level up, it's super fun. And it's really easy to get started, you know, programming languages have become much more approachable of late. And so if you're new to programming and just starting to dabble in it, you don't need to buy a big expensive thing, you know, the laptop that you're using to browse the web is probably sufficient for building simple programs. And so you know, dive in, use free tools and and just start building stuff. It's really approachable and really fun. Absolutely. And one of the things that just never ceases to blow my mind is I can be in a coffee shop, working on a relatively cheap laptop, doing my coding, 'git push', speaking of 'Git' something happens on one part of the cloud, it triggers a web hook somewhere else that then grabs the code and could run that on a tremendously powerful data center, and computer or suite of computers, a cluster of computers. And yet I get the experience of basically building this super powerful thing on my very wimpy little laptop. It's just cool that you can create things like Facebook, or Google or you name these these really large, amazing apps, but you could kind of just do it on like a laptop, something that existed in my mind yesterday, exists in the cloud and scaled to any user that wants it tomorrow. Yeah, that is really fun. Yeah, it's super, super fun. Before we move on, you also mentioned that you've been playing around with Raspberry Pi's something I covered recently on 'Python Bites'. My other podcast is somebody built a water cooled, Raspberry Pi cluster, computer. So eight Raspberry Pi's in one thing, all of them overclocked, and water cooled, have you seen people doing this stuff? It's crazy. It's really cool. And as you start to get into clustering, programming, clustered programming, you know, multi machine type of experiences, a Raspberry Pi is a really cheap barrier to entry, you know, for $40 or so you can get a Raspberry Pi, get three or four or five of them, cluster them together. And now you get the sense of what does it take to build parallel machinery. And it is really, really fun. So you know, to get an 8 or 10 or 100, or 1000. node, Raspberry Pi is pretty sweet. And it's awesome. I mean, you could do something similar with Docker, like fire up a bunch of 'Docker Containers', but it's not the same feelings. Like there's actually 8 of them over there. And they're actually talking to each other and working together. I think it's, it's a very different feeling. It's super cool, 'Containers' do help us start to approximate that. But yeah, there is some lying to ourselves to believe that all of these containers running in context on my one laptop, are really a distributed system. Yeah, absolutely. It's not the same, but it does let you sort of play around there a bit. Right. Alright. So I want to talk about Git primarily. And that's what your presentation in the Python web conference was about. And that's what we're going to center our conversation on. But you know, you and I both been around the industry for a while, "Git" is not that old. It's the new 'Source Control' on the block, I guess. So maybe, let's talk a little bit about the history of 'Source Control'. You know, I think of 'Source Control' as a spectrum, from what 'Source Control' all the way to get distributed source control maybe, you know, there's I've talked to people I've seen inaction source control is I've gotten
File code file. And I've called it version one, version two, version two edited version three, version three, final, final two, you know, just like already, maybe it's a lot of files use zip the folder and you name it like that, right? Like that's the beginning of source control means doing a wrong, but it's getting getting there, right? Well, it's doing it in exactly the way that you needed at that time, 'Copy folder' 'Versioning' is definitely a thing, '.pu'
to pivot to distributed version control systems of which 'Git' is one of them, where we have a separation between the 'Commit' stage and the 'Publish' stage. And that isn't the official terms that 'Git' or any of the rest of them use. But there's a process of marking those safe points. And then there's a process of collecting all of the safe points and publishing them to others. And that takes a bit of a mind shift to get used to it as well when you're working on it. Because if you come from one of these other systems I committed so it saved, right, but 'Commit' in a distributed source control system means it's, it's a local safe point until you get 'push', or whatever either a materials equivalent of a 'git push'es, right, yeah, and hg push. And so it's exactly that it's marking save points, however frequently you want. And then combining those safe points together into a cohesive story to 'Publish' to your colleagues. And that's what makes 'Distributed Version Control'. So powerful is separating those two concepts. 'Mercurial', git, 'Perforce', there are other distributed version control systems. And as the world was moving from 'Subversion', and 'TFS', into this Distributed world, we experimented with each of them, you know, arguably, 'Git' wasn't the best, we might have done a 'VHS' and 'Betamax' type of thing. But clearly, 'Git' has become the 'de facto' standard version control system, it is distributed. And now we can separate the safe points from the Publish points.
Talk Python To me is partially supported by our training courses at talk Python. And we run a bunch of web apps and web API's, these power of the training courses, as well as the mobile apps on iOS and Android. If I had to build these from scratch again, today, there's no doubt which framework I would use. It's 'Fast API'. To me 'Fast API' is the embodiment of modern Python and modern API's. You have beautiful usage of type 'Annotations', you have 'Model binding' and 'Validation' with pedantic and you have first class 'Async', and 'Await' support. If you're building or rebuilding a web app, you owe it to yourself to check out our course 'Modern API's with Fast API' over at 'talk Python training'. It'll take you from curious to production with 'Fast API'. To learn more and get started today, just visit talk python.fm/fastapi or email us at sales@talkpython.fm.
I think another really important thing to highlight for people who haven't been there, you know, right at the 'Git' homepage, they highlight 'Subversion', which we 'CVS' which we've been talking about, but 'Perforce' 'clearcase', 'Sourcesafe', 'TFS', a lot of these things, there's two things one, they would lock files, like, if you wanted to make a change to a file, you would claim it like I'm editing 'main.py', when no one else can interact with that file, it's literally made read only on your computer until, you know until that person is done, and they had better not forget and go on vacation while they got some files checked out. That's the one thing. The other is you need permission to participate in a project, you have these gatekeepers, and you need to sort of prove yourself to the gatekeeper. So if I wanted to 'Commit', I wanted to work on 'Flask'. If it was under 'Subversion', I have to go, can I have permission to go read it 'read only' access to 'Flask', if I want to make a change, I literally have to say I need the permission to 'Commit' back to 'Flask' with the distributed ones, you clone it, you do your proof of work, your proposed idea. And if you want, you can contribute it back. Or you could just go in a different way, right? There's this very interesting separation of I can kind of work on it and then see if I want to contribute back rather than the other way around, I have to get permission to contribute. And I think that's a super critical thing in the open source space where there's a very loose coupling of people and projects. Like if somebody comes to me says I want to work on a suppose I'm working on 'Flask', they come to me, I'm in charge of 'Flask', they come to me and say I want to work on 'Flask' like well, maybe what else have you done? Show me, this is a huge project. Yes, we do not want you to mess up Flask. But and we had a little bit of that with 'SourceForge'. You know, you could clone the 'Repository' in 'Subversion' and just work on it locally. But you weren't able to participate the moment that you wanted to help. It was a really friction full process where you know, okay, so I have this diff. Now I don't have write permissions. So am I going to, you know, bake this diff into an email and hope somebody reads it? Do I just use it locally? Do I 'Fork' the project and only have our corporate version of it? It was very difficult to participate. And that's not a
feature of Git per se, but rather the GitHub that shared hosted mechanism around get that has grown up as well. Yeah, I mean, with 'Git', you can 'Clone' a thing and then work on it, as long as you have 'Root access'. But yeah, the additional mechanisms the 'Git Flow' around it is certainly something created by 'GitHub' with
Like prs, and 'Forks' and Emerging 'Upstreams', and all that origin 'Upstream' stuff. One thing I did want to ask you, before we get into the details is why do you think 'Git' won, you did talk about this 'Betamax VHS' sort of thing. And there are other options out there for distributed source control. I have a theory, what are your thoughts? And I have a theory too, I don't have the answer. And maybe our listeners will help us discover what the correct answer is. Or maybe there isn't one. In my mind, a lot of the time, we were looking at ways to compete with things. You know, we had things that would compete with CFS or 'Subversion'. Because you know, we wanted a little bit more, we wanted to make money on the process of source control. And what's really interesting about Git is that it be it has become so pervasive. And so we're not building competitors to get we're building integrations and to get it we're building on top of Git. Yeah, arguably, GitHub helped with that, too. GitHub has a really, really powerful community mechanism for that, and GitHub really only did get. But I would argue that Git is really cool, because it's free and open source. And because it's free and open source, and it has that community mechanism around it. We don't need to compete with it. We don't need to try to make money on this. Instead, we can build collaborations with it, and mechanisms working with it, and build up the community together. My thought as well was GitHub. Yeah, it's the thing that brought not just the server infrastructure to privately have code. It brought the community and it brought the flow that allowed people to collaborate in ways that could let them collaborate, once they've proven they have something to collaborate, right? Here's my PR, I've already shown you the thing that's amazing that I want to offer up to you. Oh, that does look amazing. Thank you, who are you? Let's let's talk about this, right? It's a different conversation than I've never seen you. Why should I give you right access to 'Flask', and 'svn'. And it's exactly that 'GitHub' has these magic levels to it, we're at the very first level, it is just an online source code repository system. And so you know, how is that different from 'SourceForge' or 'TFS' before it, and it isn't at this level. And so if that's what you're using GitHub for, then that's perfect. You know, backup your local projects up to GitHub, get your content off of your machine in case there's a disaster, that is definitely the first level, the next level starts to build 'Workflows' around it, where we can say, I want to create issues, I want to create project management things, I want to create milestones, I want to create goals. And so that's kind of the next level leveling up again, we can start to create a social community around that where we can start to have conversations around the content, where I can create a 'diff', and we can all talk about it, and we can collaborate on it. And once it's good enough, now we can 'Pull' it in. Add to that, then the mechanism around pull requests and things like that. Git has a content concept of 'push' and 'pull', you know, 'Publish' and 'Receive', I guess, might be the terminology that matches here. And what's interesting about a 'Pull' request, I don't have write access to your 'Repository', but I want to contribute. So instead of 'pushing' my content to you, I'm going to 'Request' that you 'Pull' it from me. And so no longer do I need to create this email and write out all the content and hope you read the email. And I create this code up in my space. And I request that you include it in your space. And that made collaborating with projects really, really easy. So with that comes the next level of GitHub where we have these communities that can socialize, and develop and hang out in this coding space. And that's really what made GitHub so magical, is that we have this community around coding, where previously with 'SourceForge', or other environments, yeah, we had that online source control system, but we didn't have those levels of interaction. So pull requests, or merge requests, or whatever you're gonna call it is that mechanism of being able to collaborate with low trust type of environments. I want to offer up my solution to the community and see if that's gonna fit into this ecosystem. Yeah, I think that's why I get one as well. And Vera rose out there. It says open sources, the best way to learn and improve technically, in collaborative people you don't know. Yeah, I think it's that the people that you don't know, it makes it special because it allows you to create these connections with people all around the world, who you would otherwise not meet, and you get a chance to work with them. Even if you live in rural Canada and you want to do software development, maybe no one around you is
Really good at whatever you're trying to do, but go to GitHub, find a project, you can collaborate the best people in the world on that we can create these communities around our passions for technology or the problems that we want to solve, not necessarily based on the geographic boundaries that we find ourselves in. Yeah, absolutely. All right. So that's the history of it a little bit. Yeah, talk a little bit on why 'Distributed Source Control' is really powerful. And I think it is really unlocked open source in a special way. And on a much larger scale than it has. And it is interesting to note that 'Git' and 'GitHub' are different. 'GitHub' uses 'Git' under the covers to be able to build it social experiences. But 'Git' is a thing that is separate and distinct. There is no 'Pull Request' concept in 'Git', for example. And with 'Git' on your local machine in a cave, you can 'version' and 'create' those safe points. When you're ready to socialize, to 'Publish' your content to communicate with your team, you can use 'Git', together with lots of services, 'GitHub', or 'Bitbucket', or 'Git Lab', or there's lots of private services as well that allow you to create that online community. Now, GitHub has published their magic sauce to the world, and lots of us have cloned it. So 'GitHub' is still the place where we code for the most part. But if you prefer coding in another community, then that's totally fine. You can still use 'Git' and all of the tools to be able to 'Version' create your 'safe points' and 'Publish' that content to others, you could just 'Publish' it to a different server as well. 'Git' and 'GitHub' are different. It's easy to see them as the same thing. But yeah, they're absolutely not. Right, we've got all these different locations. You know, I've mixed emotions, mixed feelings about if you have another project, and you put it somewhere else, I'm not going to name any particular service. But let's just say somewhere that's not 'GitHub'. That's totally good. But at the same time, so much of the Open Source flow is around 'GitHub' and the stuff that's happening there, it's I don't know, it's really interesting to think if why you might be at one place and not the other place, and so on. Yeah. And a lot of people were worried when GitHub was bought by 'Microsoft', is this going to be the end of the community collaboration. And I think 'Microsoft' has been a really good steward of the 'GitHub Community', and really making sure that 'GitHub' is still available to all of us and facilitating the success of that ecosystem. Yeah, there was a lot of hesitancy and concern within certain communities. And I feel like they've done a great job. I guess what I didn't realize was that GitHub really needed some help from somebody, like they financially they were not doing as well, I looked in like, this place must be incredibly successful. But you know, what came out after when some of the reports and stuff that was you know, it was kind of important that someone came along. And if that's the case that I was, you know, head over heels that Microsoft bought them. Last thing I want to see is them go away, and I think they've done a good job of just letting them be alright. Yeah.
It's working really well. So I think it's, it's been a good, good deal that worked out there. See also 'Docker' for an example of a community that is amazing and contributing, but doesn't have a financial business model to be able to survive. Yeah, yeah. Hopefully, things go well for 'Docker', but it's just tricky. They tried the enterprise thing. And then they're, yeah, they're switching to other things. Yeah, I love their pivot back to focusing on 'developers' in the community, which is wonderful. But I still feel like they haven't found their spot that allows them to be business successful. And the hard part is, you can only do that for so long. And then you need to, you know, pivot to something that can start to facilitate the business. Yeah, absolutely. All right. Are you ready to go into the 'Git Folder' and find where the hidden magic lives? Yes, if you go into a project that you've get cloned, or you've get a knitted, and you create some files, and you mess around there, you don't see anything different, it looks just like any other folder that might have a project in it, right. But in there, actually, it's contained the, almost the entire backup the entire contents of all the versions of those files, at least every branch that you've checked out, hidden in the 'hidden.git file', So .gbit On and it's not almost it is that is the entire history of the project. So the way to backup a git database, misusing that term, is to grab that '.git folder' and copy it. Inside that '.gitfolder' is lots of files that describe the history of the project, since its inception, down to the current version. And so you know, kind of the only way that you can break Git is to open up that  '.git folder' and change stuff. By default, this folder is hidden on most systems. So you may have to show hidden files and folders to be able to see the '.git folder', but it's there. And it's really powerful. Yeah, so
On Windows, you go to Explorer, there's like, one of those little ribbon things that drops down is a checkbox for Show 'Hidden folders' and 'files'. On Mac OS, I learned you can hit Shift+Command+. , and that will show hidden files I that I did not know when I was very delightful. And some users are delighted when users told me about that. On Linux, I don't know. I mean, you could go and do an LL in there on the terminal. But there's probably some way to show it in the Explorer equivalent as well. You can navigate into it from your terminal or wherever. And once you're inside of it, yeah, all of the files are right there. Yeah. So we go in here, and we find things like 'Head', 'Config description', 'Hooks', 'Index' info, 'Logs', 'Objects', 'packed ref's and 'refs', you want to maybe give us a rundown of what each one of these are. And then we'll, we can dive deeper with one of the tools that you built into maybe some things like refs and so on. But yeah, yeah, hooks, but yeah, wherever you, what cool in this database, is, it is the entire history of your project. And it's' z lib- compressed'. So for example, the 20 year history of 'Pearl', the '.git folder' is ever so slightly larger than the 'Checkout folder'. And that includes the entire history, including all of the changes, and all of the authors. And all of that is really nicely compressed into this. Well, it breaks down into a couple of groups of things, we have the 'Content', we have 'Branches', and 'Tags', you know, 'References' to the content. We have 'Configuration' details around this 'Repository', we have 'Index' files, we have 'Temp' files, then we have 'Automation' tools. And so these are kind of the groups of things that will find in this folder, a lot of them happened to be in their own folder, which is really nice. So for example, 'Hooks' is the place that you go for 'Automation'. 'Refs' is the place where all of the 'Content' is, but no .refs is the place for 'Branches', 'Objects' is the place for the 'Content'. And so a lot of the things that we'll see will have their own folder, but some of them spill out, like 'Configuration' is in the 'config file'. But there's also some stuff in the 'Info folder' for that 'indexes', we've got the 'Index file' right there on the 'Root directory', but we also end up with index files inside of 'Pack Folders'. And so, you know, it gets a little bit interesting. The first one to dive into is probably the 'Objects folder', because this is the stash of all of the content in your 'Repository'. Now as you 'Commit' something into 'Git', you'll first add it to the 'Staging' area, and then you'll 'Commit' it with a message. And as you do so, you'll end up with content inside the 'Objects folder'. Now, what's interesting to note here is if you look at a 'git log', you'll see hexadecimal thing you know, it might be seven characters, or it might be much longer than that. And as you do that log, you can take a look at that inside the 'Objects folder' are folders with two digits, those are the first two digits of the 'Commit number', inside that folder is all of the 'Commits' that happened to start with that two digit number, or letter. So you know, that means that not all of the files will be in one directory, they'll kind of be arranged a little bit that gets around too many files in one directory, or hers. But it's that that objects folder that then stores all of the content there. Now, what's interesting is, I think of it if I 'Commit one', and that's where this talk was really cool. When I 'Commit' one thing, and I go look in that 'Objects' folder, I will have 3 different files. Now they are 'z- lib compressed'. Yeah, you can't just open them up and look at them, right. They're kind of right scrambled up. But it's not magic. You know,  I built a tool that will 'unzip lib', compress one, which is pretty cool. But once we identify a thing that we want to do, we can also use 'git-cat-file'. 'git-cat-file' allows us to look at both the 'type' and the 'content' in a particular node. This is a directional  'Acyclical Graph Nodes', 'Dag nodes' that specify relationships between these things. But what's cool is, here's an, here's an, here's a file that's in that branch, something like that. They're not branches, but they are folders. Here's a file within a folder. Here's the content. So we have three different types of these nodes. One is a 'Commit', and in the 'Commit', we have the author's name and the date that it was 'Committed' the message that we gave, and also in that 'Commit' is a 'reference' to the 'tree' nodes' that are part of that 'Commit'. Now each 'tree' node can specify 'files' or 'folders'. So a 'tree node' can reference another tree node. And inside the tree node, we have references to those files.
So I might have a tree node that references file, '1.txt', the third type is a 'Blob'. And so as we look at 'Blobs', then that's the actual 'content' in the thing. So go back to the click on 'File', I don't think I have a one to get back to the blob. But the cool part about this app, hit 'Refresh'. And you'll get to that 'big Blob of stuff'. Here's all of the 'Commits' in this 'Repository' to head so we had something visually to look at here, and it's about to pull up. It's rendering. Yeah, it's not super performant. That's all right, you built this thing called 'git-Explorer', which is a little web app that runs that you pointed at a 'git repository'. And it lets you look at these things that you're describing visually, and then click around on them, right, right. So click on show 'Type', and we see the 3 different colors emerge, there are 'Commits' 'Trees' and 'Blobs'. And it's like, Okay, I have a whole bunch of files in my 'Objects' folder. And I can click on each one, and I'll use that 'git-cat-file' thing to go figure out what it is. But it's like, you know, I really wish I had more stuff about it. And so that's where I click 'alphabetical'. And that will put them all in order, click on 'tags', and now you can see the name of that thing. And I'm only showing the first 7 digits of the 'Commit' here. But now you can kind of get a sense for here, all the 'Objects' and click on each one and open it up, right. And these names are what often go by Shaw's in 'git parlance', which is just the type of 'hash SHA', whatever it is. And I don't know how many people know this. But you can use sub pieces of the SHA's refer to it in 'git'. So you don't have to say the full I know what is that 32 characters or whatever to describe a name along with its enough to be unique. It'll go like you can issue 'Commands' against these things in this abbreviated form. Right? Right, exactly. So oftentimes, only two digits is necessary, sometimes three or four. And that's why often when you're looking at Git history, it'll only show you the first seven, surely enough, yeah, now, we start to do as we're clicking through this, as we get a feel for all of these green nodes, that's the 'Content' in the 'files', the blue nodes of the tree nodes. And as I click on one of those blue tree nodes, then it references other files, I can see there, 'SHA's' there, 'git hashes' there in that list. And then as I look at the red ones, the commits, that's my 'Commit' message that includes the 'Parent' node, that was the 'Commit' right before this. It also references the tree node that has the files for this. And so Wouldn't it be nice if we could, I don't know, arrange them in a way. So let's, instead of going from alphabetical, let's click on 'Parent child', and start to see the relationships, we'll need to turn on lines. Now, we probably want to also turn on tags. And now we can take a look at those 'Commits', and see how each one references. Now if you have a very large repository shoots off, then I haven't built scrolling yet. Sorry. Yeah, but you can see that the 'Red commit' nodes all reference each other, and reference the previous ones. And then they go into these tree nodes that may reference other tree nodes. And eventually those reference the file notes, that's part of my demo, highlight that, if we create the same file content, and 'Committed' in 2 different directories, it's actually only one 'Blob' on desk, there's only one 'green blob note'. But the cool part here is we were able to explore each of these objects in our 'Repository', and we get a feel for how they work. So if I change one line and a very big file, what gets committed? Well, the entire file. Yeah, that's suspect. That's probably why large binary files are not ideal to be 'Committed' here, even though we technically can put them there. Right? So that's the first group of things is these objects. So that's the top level 'Objects folder' in the 'Docket' folder? Yeah, yes, exactly. Now, there is a 'Pack folder' inside there. If you run various commands, then Git will say, well, do I have too many Commits to many of these objects that I need to, you know, 'Pack' together to make this repository smaller on disk, and if so then it'll automatically do a GC a 'garbage collect', where it starts to pack those into pack files. Now it's kind of a 'z- lib', compressed group of 'z-lib compressed' files. So it gets very meta there, but that's what the 'pack folder' is inside the 'Objects folder'. Okay, so next up, let's talk about the 'Refs folder'. Now when we look at 'refs', we look at 'Branches' and 'Tags', and remotes. These are files that 'Reference' 'Commits'. So one example is the 'HEAD folder' in the root of the  '.git directory'. And inside that 'HEAD' folder, it will specify
What 'HEAD' points to. So if you do a 'git-log', and you see that 'HEAD' has an arrow pointing to I don't know, mean, or 'Trunk' or 'Develop' or whatever. Then if you open up that 'HEAD' file, you'll see the text in that file is that file, it's basically the 'SHOT', right? Is that what it is? It is the 'SHOT' if your 'HEAD' is pointing at a 'SHOT', but typically your 'HEAD' won't be pointing it, a 'SHOT' will be pointing at a 'Branch'. Oh, yeah, 'Refs' like mine right now is "refs/heads/main", which is the default 'branch' for this project. So that's awesome mean being the 'branch' 'Head' says it goes to 'refs' 'Heads' mean, so we can go into the 'Refs' folder, we can go into the 'HEAD's folder, and we can open up 'Main'. And what's in 'MAIN', is the 'SHOT' of the 'Commit' that 'Main' points do. Okay, what's cool here is that each of these 'refs' both 'Head', and all of these 'Branches', is just 'Pointers' to the 'Commits' in the 'Objects' folder. Yeah, so these are like, the 'Main' file is just a text file that just literally has only the 'SHA', it is where that 'Branch' currently is. Exactly. Okay. So technically, to create a 'Branch', I just create a 'file' that happens to be in 'refs Heads', I name it something and I give it a SHOT. And now I have a 'Branch' that points at that thing. 'Branches' in Git are not these durable, fragile things like in 'TFS', or in 'Subversion'. 'Branches' in Git are just 'name' tags, their pointers, their 'references' to the 'Commits' in this tree of 'Objects'. So the cool thing is we can move them around by the basically a path of these named 'Commits' through the history of the overall history of it Right, right. There the 'Labels' that we give it so that we can understand it, because communicating in 32 digit 'SHOTS' is not as much fun. No, definitely not. Definitely not one of the talks that. I like to do is I do a 'git-log', and I show that 32 digit 'hash', and I, I read it out, and then I walk up to somebody in the audience and pretend they're the project manager, and I go, can I ship it?
And they're like, uh, uh, yeah, thus, we have these 'Labels'. Yeah. Now in the 'HEAD's folder, is all of the 'Branches' in the 'tags' folder is all of the 'tags'. And there are also just files pointing it 'Commits'. Sorry, my repo is empty. They don't have any, but if you you know, people might tag a 'release' or a 'version' or a 'beta version' or something like that. So you can refer to it by 'name', by 'Label' instead of, you know, 'Main' with  'SHA' or something weird like that. Right, right. And then we have our 'Remotes' folder, which 'References' where I last saw another copy of this Git 'Repositories', 'Branches'. Yep. So in this case, you have one that says 'refs', 'Remotes', 'Origin', 'Main'. And that's perfect. That's where I last saw this server, the server's 'HEAD' main direct 'main' 'Branch'. Now in this case, I chose to call my 'Main' my remote 'Server' origin. Now, this could be a server that we've designated as the server, it could be one of my co workers, it could be a network share, you know, 'Git' isn't really opinionated about what constitutes a remote repository. Other than that, it isn't this one. Yeah. Okay. How does it know what, what origin is, as I create a 'Remote', I'm going to 'name' it, okay. So as I clone, I'm going to say 'git-clone' this 'Repository', and it'll build one and it'll by default, call it 'Origin'. But I could also say,
We probably don't want to touch that one. But that's the base configuration of all the options that we chose. When we installed Git two, if I run a command, if I were to say something like, get email global, something like that, you know, with the  '-g command', maybe it's modifying that one. Well, the one that we just talked about was the system one. The second one is the global one, which is user specific, I find that confusing. Yeah, but my user specific the '.git-config' in my user home directory, so you know, C users, Rob or user, or the tilde a '/directory', Mac, and Linux, that '.git-config', overrides any settings in my system configuration. And so oftentimes, when you first install 'Git', you'll say, 'git-config'-globaluser.email, 'user.name'. And so if you open up that '.git-config' in your user home directory, you'll see those settings, you'll see your username, your name, your email, and all of the details that you've configured there. And then the third one is the
Yeah, I mean, you might say we want a 'private' git-server, or 'public' git server, or something like that. That might be but yeah, usually, I've never heard of it. So very interesting.
All right. What else is in this? This list here? Yeah. So we've talked about the 'content' in 'Objects' folder. We've talked about the 'Branches' and 'tags' and the 'REST' folder. We've talked about configuration? Let's go poke in the 'Hooks' folder. Yeah, 'Hooks' is interesting. Yeah, it is really cool. The 'Hooks' folder is where we do 'Automation'. Yeah, so people probably heard of 'pre-commit-hooks', right? Like, probably the most popular example in the Python space is to run the 'Black formatter'. So it automatically formats your code before it checks it in. So indentation whitespace, like between a comma in an argument or something always consistent. So you don't get these like back and forth. editor driven, you know, merge issues, but there's no real change. But I format in my editor, you format it and yours, and back and forth. It goes between spaces with the comma, no spaces with the comma space with the comma. And so you could set up a 'pre-commit-hook' to canonicalize it before it goes in, right. But there's more than pre commit, right? Yeah, I could set up a 'pre-commit-hook' to make sure all my unit tests pass before I 'Commit', I could set up and so what we see here in this 'Hooks Directory' is all different kinds of 'Automation' things. So 'pre-commit-hook', a 'pre-merge-hook', a 'pre-push-hook', a 'pre-rebase-hook', and each of these are 'Shell' scripts. Well, with one exception, it's a 'Perl' script. But you see at the very top
It says '/bin/sh'. Why am I on a Windows box? Is this 'Shell' script still gonna work? Oh, yeah, 'git' ships with enough 'Linux C', 'Unix C bash', like stuff to be able to kick off the 'Shell' scripts and run them as it would on any Linux system. Okay, interesting. So there's basically like a little mini bash that comes with it, I remember people using that 'bash Shell' from 'git' to be more Unix like on Windows Exactly. So here in this 'Shell script', I could do all kinds of things. Maybe I'm calling a 'PowerShell' script, maybe I'm calling a 'Python' script, maybe I'm calling a 'Node format', or I can just call into whatever tasks I want to accomplish. And that will then accomplish that task whenever this event happens. So what I love to do in my demo, is remove all the '.sample pieces', so that their actual scripts, and then just merely the presence of that file, will be able to kick off that automation. Alright, so there's a bunch of files that our sample 'Shell' scripts named things like
'git' SHA  of the 'Commit' that it went to and a little bit about that 'Commit'. This is a log of where our 'Branches' have been. And so we'll have a file for each of our branches. In this case, we're looking at that Head file. So we see that Head started out nowhere and ended up at EDI13FC, and it has my username, my email, and then some other stuff. Yeah, the really interesting thing is this log can be really useful. If, for example, I switch branches and forgot where I was, or I commit something, and then I uncommit it, that's a thing. And I want to get back to it, or I delete a branch before I merged it in or, you know, those types of things. If I do that quickly enough, you know, remember gets gonna do that garbage collect and go prune nodes that aren't used anymore. If I get there quickly enough, I can use this log to go back through my refs, and go find that commit, the objects are still there, I just don't have any refs pointing to them anymore. And so the command that we can use on the command line is called 'git-ref-log'. And we can pass 'git-ref-log' a particular branch we want to look at, but by default, if we just say 'git-ref-log' all one word, then it will show the history of 'Head'. Now in this case, we didn't move it very far. But we can see there Oh, and here's the branch that I just deleted. And here's the SHA for this one. And so at that point, then we can 'git' check out that commit and get back to the content that we had created. And then last the reference to right. Okay, nice. There's a little bit of recovery, kind of an undelete. If you had to in there. Yeah, nice. The funny thing about this, the command is 'git-ref-log', but I've also heard it pronounced git ref log. And I'm like, so I've got this cat of nine tails. And I'm like, No, you can't get reflux. Exactly. Do it again. But once you understand how the refs folder works, then 'git-ref-log' makes a whole lot of sense. We're looking at what those ref files have said in the past. Here's what was before we changed it. Here's what it became, after we changed it a little bit more context around where you're currently working is where the head is pointing. Often that some Yes, branch. And this is like, Where's the history of that 'bin'? throughout the branch that it's on? Yes. Yeah. Very cool. Very cool. So we're getting sort of short on time here. What else should we be talking about? Like what else? I mean, sort of should we close this out with in terms of content of our dog file giveaway, the only other section in here is 'temp' files. So if we've 'committed' stuff, we might see a
All sorts of things should not go into your project. Right? Your VF directory? Yeah. Yes. Exactly. Your VF directory? Absolutely. So yeah, there's 'gitignores' any content that you download any content that you compile any of that content shouldn't be in your repository, because it changes too infrequently. And it's usually easier to either rebuild it or redownload it, all those things should be ignored, yet, it's a huge merge nightmare as well, even if you could keep it, right. Suppose I check in my 'VF directory', and you go on Windows, well, you can't have the same contents as mine, because mine is the Mac OS version. So you change it, put your Windows version in there, and I get it back out and it breaks my Mac versions I got right those, there's stuff you should ignore. Absolutely. And when you create a new project on GitHub, it very handily says, hey, what kind of projects is this, we can get you far down the road with your 'gitignore'? Is this a Python project? Is it a node project or whatever? Right? What I wanted to point out is that drop down list, there's actually a GitHub project called 'gitignore', that has the ignore for all of these different languages. So if you want to make a change, to say, pythons-gitignore', you can go there and pull it up and see it. And you could technically do a PR, against it to say there's this new thing that's common in the community now, please fix it. That's pretty cool. And these things aren't perfect. You know, most of them will exclude everything that starts with or ends with or contains log. But your 'ilogger' or your
Was I could clone only part of a repository. And VFS kind of gives us that ability back most of the time, we don't need it. But if you've been really bad, and you've committed a whole bunch of binary files to your repository,
it's interesting, it might be worth kicking the tires. It isn't necessarily windows only it is plugged into Git itself. But it allows you to put that checkout directory somewhere else. So for example, on a shared file of shared network drive, now I have all of those objects, all of those blobs in one place, and I don't need to copy each of those to my machine. Yeah. interesting. The windows people that were switching to get said it was really a nightmare. So for example, the source code for Linux, repo something like 600, Meg's or point six gigs, Windows is like 270 gigs. So it's really ginormous. And they said, to do a clone took 12 hours to do a checkout took three hours to do a git status took eight minutes and to do an add and commit took 30 minutes before they made this change. So they were suffering some hard pains to go down this path for sure. I guess it probably is worth it for them. Right. All right. Well, I guess we probably should put a bow on it. We're more or less out of time there. But yeah, I'll ask you the two questions I always ask at the end of the show. If you're gonna write some code, what editor do you use? It depends on the code that I'm trying to write. In most cases, I'll reach for VS code, but also reach for Visual Studio, right? If you're going to be doing 'ASP.net' stuff, like you said, Sometimes I'm also known to reach for, if you're doing like ASP. net or something you were talking about like that, or something, maybe something like, 'WPF' where the tools are built in, you have to basically have to almost Yes, but sometimes I also reach for Sublime Text or TextEdit, buku. And then often asked for a Python package library recommendation, maybe we could make it your Git scripts, the one that runs the 'pre-commit-stuff'. And when that moves that outside the Git folder, what was that called? Again? It's called Git hooks. And let me grab a link to it. It's actually a node package. But Exactly, yeah, just install it wherever. And it's good to go. Right? Yes. And so if you have maybe a Flask server, and you want to, as part of your 'Flask' server, maybe you have a 'React' or 'Vu' app where you need to pull down 'jQuery' as part of your client side dependencies, then you may have enough node stuff to be able to leverage this as well. Yeah, yeah, that makes a lot of sense. If you're already using NPM, because you're doing front end stuff, then you might as well, right. Yes, yeah, very cool. Other things that we didn't talk about. And it's really cool how this happened. 'Git Workflows'. what's beautiful about Git is really opinionated about how you do your workflow. Are you going to do Git flow? Are you going to do GitHub flow? Are you going to do something else? Git can work for all of those scenarios, because it is just a mechanism of committing and sharing files. It doesn't impose a specific branching or naming convention, you can choose to put those on top. But 'git's workflow is really open to whatever you need it to do. Yeah, well, when I was first getting familiar with this whole prs, and merging and those kinds of things, I felt like, Oh, that's a 'git' thing. That's a GitHub thing has nothing to do with 'git', right. It just get facilities that on top of it. So you can choose however you want to work. Right, right, by Cool. All right. Well, I don't normally close out this show with a joke. But Robinson had a good one here in the live stream. So I'm going to put this up here for us as our parting thought, and then asked you for one more as well, maybe, yeah, so he said, there's a programmer once told him couldn't use Git. He was afraid to commit.
Afraid of the 'git commitment'. Oh, that's awesome. Yeah, thank you for that. Thanks for making us laugh. Alright, final call to action, people want to go a little bit deeper than get may be they just do the three commands
Specifically, separating the save points from the Publish points. That's the thing you couldn't do before that you can now do with 'git' well said, definitely agree with all of that. I think getting really good with source control. And source control these days really means get almost, it allows you to be fearless with your code, right? So often people like, I would like to try this. But what if I break it? What if it doesn't go right? Well, if you know how to you know, create your branches work locally, do all sorts of stuff, rollback, you can just go crazy and just explore things. And if it doesn't work, you know, throw it away. No harm, no foul. It's lovely. Then if you get really stuck, hit me up on Twitter '@rob_ridge', and show me the code where you got stuck. And let's get you unstuck because I would love to continue this conversation and really help you be successful. Awesome. All right. Well, thank you for taking the time and being here. It's been great to chat. Get with you. Most definitely. Thanks for having me on. Yeah, see you later.
This has been another episode of talk Python to me. Our guest in this episode was Rob Richardson. It's been brought to you by our courses over at talk Python training. On level up your Python. We have one of the largest catalogs of Python video courses over at talk Python. Our content ranges from true beginners to deeply advanced topics like 'Memory' and 'Async'. And best of all, there's not a subscription insight. Check it out for yourself at 'training.talkpython.fm'. Be sure to subscribe to the show, open your favorite podcast app and search for Python. We should be right at the top. You can also find the iTunes feed @ /iTunes, the Google Play feed at /play and the direct RSS feed at /RSS on talk python.fm. We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talk python.fm/YouTube. This is your host Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and write some Python code
