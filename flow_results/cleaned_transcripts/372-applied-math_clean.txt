Often when we learn about or work with math, it's done so in a very detached style. You might learn the rules or techniques of differentiation, for example, but how often do you get to apply them to meaningful and interesting problems?
Episode we have Vincent Knight and Grant Palmer on to discuss a wide variety of applied and approachable math problems using Python. Whether you're deeply into math or not so much, I think there's a lot to enjoy from this episode. This is Talked Python to Me episode 372, recorded June 29, 2022.
Welcome to.
Talk Python Mee, a weekly podcast on Python.
This is your host, Michael Kennedy.
Follow me on Twitter where I'm at McNutt and keep up with the show and listen to past episodes at Talk Python FM and follow the show on Twitter via at Talk Python. We've started streaming most of our episodes live on YouTube. Subscribe to our YouTube channel over at Talkpython YouTube to get notified about upcoming shows and be part of that episode.
This episode of Talk Python and May is brought to you by compiler from Red Hat. Listen to an episode of their podcast to demystify the tech industry over at Talkpython Fmcompiler, as well as the Python at Scale Summit Conference being held in October. Reconnect with your Data science colleagues this year at Talk Python slash Python at Scale. Please check out what they're offering during their segments. It really helps support the show.
Transcripts for this and all of our.
Episodes are brought to you by Assembly AI.
Do you need a great automatic speechtotext API? Get human level accuracy in just a few lines of code?
Visit Talkpython Fmassemblyai a quick announcement before we jump into the show. You probably know about our video courses. I'm super proud of them and they are a fantastic educational resource for many people. But sometimes you can benefit from a more hands on, group based approach. That's why I'm running another online cohort course. This one will cover Fast API, Async, Python Programming and MangoDB.
However, the structure is different this time around. This course will be taught 100% live in person. You'll attend over Zoom, and all the sessions will include myself as an instructor and your fellow students.
It runs from August 8 to August 19. If that sounds interesting, please check out the link in your podcast player Show Notes or on the episode page. And if your company offers educational credit or training reimbursements, you should be able to expense this course as well as our regular Talk Python courses. I'll put some links to templates that you can use to help with that in the Show Notes as well.
Vince Garnt welcome to Talk by Thundermee.
Thanks, Michael. Thank you very much for having us. Thank you.
Yeah, thanks. Nice to be here.
Yeah, it's great to have you, Vince. I guess it's welcome back for you, right?
Yeah, I was on the show a while ago and big listener love the show. Yeah. I came here a long time ago to discuss one of the Game Theory libraries I work on. So, yeah, thanks for having me again.
Yeah, you bet. I love Game Theory. It's amazing. We'll touch on that a little bit. We're going to do kind of a survey of a bunch of different areas of applied math and how Python and compare that with how our might solve those problems. Some of the libraries involved, some of the techniques involved. So lots of fun things. I'm looking forward to diving them into them with you.
Awesome.
Yeah, awesome. But before we do, maybe we'll kick it off with Karen. You're new. Tell people quickly about how you got into programming Python Math. How did you end up here on this show?
I'm a lecturer at Cardiff University in the School of Mathematics, so I learned to program when I was doing my PhD. Vince here was actually my PhD supervisor, so I essentially learned programming from Vince during that time.
Nice.
Yeah. And during my PhD, I sort of realized I learned that everything that we'd been able to learn during my masters and stuff, it was all completely doable in open source software. And that's where I focus my paper. It's kind of where I focus my PhD. And then I sort of one of my main projects in my PhD was building a library to be able to do some of this stuff. And then, yeah, I passed, then my PhD.
What general area was your PhD in? I know Map, but what specifically?
Discretion simulation was where I specialize in my PhD, but, like, in conjunction with some of the other techniques, something like Markov change in Qing theory, which also have different ways of solving the same sort of problem. And that's where I sort of specialize in fun.
Yeah.
Very cool.
We have a running joke with Darren that one of his subtopics in his PhD that he became hyper specialized in as PhDs go, was his deadlock. And so there was a tweet came up about a question about deadlock and all these jokes that come up, and we are very excited, but I got very excited. All right. Someone's joking about your work.
That's fantastic.
Vince, you've already told your story. Maybe just a quick update. What have you been up to in the last couple of years?
Yes, in the last couple of years, having the pleasure of working with Garrett now, now that he's a colleague of mine, but otherwise continuing my work on the actual library, which is the library we were chatting about just now. And, yeah, I'm still a mathematician at Cardiff, where the best part of my job is getting to teach people how to program. And that's I think mathematics is such a cool subject, but in a way, you're only ever a theoretical mathematician until you can program the stuff you're doing. Even the appliance is quite theoretical. And then it's. Once you can code these things that are so powerful, it really kind of releases the magic of mathematics from a less cringey type of way of saying it. So that's kind of what I really enjoy doing and what I keep doing kind of what we're going to be talking about today.
Fantastic. Yeah, absolutely. We're kind of touch on a bunch of different manifestations, basically.
Cool. I want to put out a quick disclaimer. We're going to be talking about math things, obviously, Python things as well, on the Python show here. The disclaimer is I have some degrees in math, but I have not done anything with them for 20 years, and therefore I know just enough to ask bad questions and make poor assumptions. So you don't have to keep me on track and just tell me no, Michael, you are totally misremembering that from your courses 20 years ago.
The real problem is we might just be on just the other side of that boundary where we could confidently give you bad answers, is the problem.
Yeah, sure. All right, cool. Well, let's kick this off by just talking about what is applied mathematics, because one of the final courses I took, it very much confused me both in the content and just purely in its title. This was the course at UCSD and the PhD program there. The course was titled Applied Abstract Algebra.
Right.
Applied because I really don't I just.
Need to start out with we're going to be talking about solving applied math problems. Like, what the heck is applied math versus what am I doing a calculus class where I'm solving a bunch of formulaic type of problems versus real analysis, where I'm changing theories to derive new ideas? Or maybe it's numerical analysis or stats. Like, where are we in the math world?
Yeah, I think applied mathematics is an interesting kind of, like term, because in a way, it's destroyed from its meaning in a lot of cases, in that there's a whole area of applied mathematics as a subfield of mathematics that's not necessarily applied in any realistic sense. I don't know what you think.
Yeah, so I think traditionally what Applied Mathematics was when I was doing my undergrad, was these sort of physics models where they assume no gravity and they assume no friction and stuff like that, which doesn't seem very realistic to me at all. Whereas when me and Vince have been talking about applied mathematics, sometimes that goes under another name called operational research or operations research. But we call it applied mathematics because we're applying various techniques in mathematics to a situation, a real situation.
Right.
I do think not necessarily by definition, but just in general, different techniques that apply to the more physical problems, to the more management style problem. Maybe that not by definition. It doesn't have to be like that. It's just that's what people find useful.
Yeah. In a way, a lot of these labels in terms of the mathematical, like, sub fields and things are not terribly helpful because they kind of create barriers between these fields. This problem I studied in my PhD, where it's in pure enumerative combinator, it's trying to count these types of matrices, really a problem, actually, with a whole other series of conversations. And the most elegant proof that came for this conjecture came from statistical mechanics, whatever that means. But it's a field of mathematical physics and it's where, like, all these boundaries from fields not always are helpful, whereas really, the techniques are the helpful ones and knowing when to apply them. The definition that we would use for the purpose of what we're talking about today in terms of applied mathematics are just without necessarily going to an incredibly high level of mathematics, where you're talking about the stuff that they do at CERN. That is certainly why there's some very low hanging fruit I don't know if that's the right word, low hanging fruit.
Where mathematics can vary day to day problems.
Exactly, day to day. And it's where you take these ideas in high school where you're told all matrices are important because computers can do mathematics really quickly with them, but you don't do it with a computer, so who cares, right?
They tell you it's important for computers and then you proceed to do it by hand for the next two weeks.
Exactly two weeks, if you're lucky.
There's some value to that, but yeah, exactly. You're like, Well, I could tell you whether this matrix is singular or not, but I have no idea why I would do that. Right, so this is sort of the next step.
If you have that kind of knowledge, what would you do with it? What kind of problems could you answer? And some of the examples that you all cover in this book that we're going to highlight a little bit are things like if you have two businesses that are competing, what choices might they make? Or if no, I know this is extremely theoretical and it's never going to happen, but what if there was like a pandemic and there were people who were sick?
We thought, that funny, but yes, we.
Needed to make weird trade offs about society, like, shall we shut everybody in a basement? Should we make them behave in different ways? What's the cost versus benefit analysis and those kinds of things. Right.
Without needing too much high level mathematics, you can describe them mathematically, relatively simply, and then just with a little bit of code, you can really do cool stuff with it just doesn't take much code. And that's where Python really comes in.
Yeah, for sure. One of the things that we'll see throughout here is there's a bunch of different examples across these different areas of math in these different types of problems in different libraries that apply to solving them. But the thing that's cool is every one of those solutions fits within a couple of pages on the long ones right. For Jupiter notebooks that have the solutions plus have some of the output of the answer. Right.
It's not a ton of code, is it?
No, exactly.
This kind of touches on something else that we were going to talk about is the idea that a lot of the time when these things are taught, they're taught with specific pieces of software, mostly commercial pieces of software.
Yeah.
And the topic itself is kind of not separated from the software used to attack the topic. We often go into meetings with industrial partners for research products, and they talk about the tool as opposed to the idea. And that's a pity because that makes the idea much more complicated than it is, because all of a sudden you have to take apart this really complex idea. But often with open source software or with Python and R, which are the two examples that we've used, it's like three lines of codes to find out the effects of a pandemic or.
I also think it demystifies things a little bit, because if what you do is you go to some expensive polished piece of software like maple or something, and you say, well, I can ask this expensive, complex, huge piece of software a question and it can magically give me the answer. Yeah, it's great that you get the answer, and it's great that, you know, you have this very fancy tool, but it doesn't necessarily reveal a ton of understanding because of it. Right.
And I did beginning to form, I had I was just saying this to Darren, I haven't fully formed I think there's a blog post that no one's going to read that I want to write one day.
The essence of it about teaching these fancy commercial software. Why these great companies give out the educational software is that they immediately have lots of users of the software that don't know how to use anything else. And I wonder if ethically, as educators, if that's okay, I think we should make more of an effort to separate the concept from the software. And I was kind of like saying I don't think we should teach any commercial software. Darren, you made a good point when you're chatting.
I don't really have a problem with teaching a particular topic through commercial software as long as we teach it in a separated way. So that, you know, once you've formulated the concept and the ideas mathematically, you can use whatever software you want. In the classroom, we haven't had this expensive license, we can use this. But outside of the classroom, there are other things you can use.
Well, I think there's a couple of aspects here. One, Vince, you spoke about the ethics of it. Is it the right thing to do to basically reinforce this loop? Exactly, entrenches some of these. The other part is if you're in the UK or if you're in the US. And you say to your student, probably, especially if you're in the US. They're used to getting so much. I just paid for both my daughters to go to college. So I'm aware that here you pay a lot for the actual tuition, but many places you'll say to students, what is it in the UK?
What's the affordability? I know in Germany and other places, but I don't know it that well.
There it's a touchy subject in that tuition fees have just come in, and so cost of universities here are equivalent not far off to in state tuition in public universities in the United States. I think they're interested not far off, but then we get to charge I'm saying we are very not told about me, but we get to charge whatever we want to a certain extent, people from European Union and then even more to people from outside of that. Actually, I don't even know if that's true about the European Union because of recent events anymore. Yeah.
Sure, okay. So going back to my point about the ethics, was it's one thing to be in the US. Or places in Europe where we have a decent amount of money. It's another to say to somebody, you have to pay $500 for this software to learn the subject, right. Where $500 might be the yearly income for an employed person and they're a student. It seems like there's a lot of good will be done by building up maybe the missing gaps that force or encourage people to go to this commercial software building that up rather in the form of Scipi libraries and the Python data science stack in general. Absolutely. So that it's free, open source and all those things.
I think that would apply for all subjects. I think pretty close to what we're talking about here is with mathematics, I think it's really frustrating because maybe I'm thinking too purely now, but I mean, pure of heart, not pure mathematics in terms of like mathematics is just such a clean and minimalistic subject. You know, you need a pen and a paper to do it. And it's all of a sudden we're teaching people to use a pen and paper to do mathematics and saying like, Oh, but you can only do it with a pen made by a bick, but don't worry, right? And then once you graduate, if you want to write down this idea again, you have to use a big pen, but you have to pay for it yourself. And I really do think mathematics, the evolution of mathematics and a lot of science, I would argue, is into computing, right, is into getting computers to do it. And that extension of using the pad now is to use code, for me, at least.
I think one of the important things is that separation of mathematical concepts through software, because it's a lot less of a problem, but there's still a problem going the only way you can do this is by using free Open software. Yeah, there are some places, unfortunately, that are not allowed to use Open Software because they think the security problems and stuff. So if you've only told Open Software then like the NHS for example, I know they discourage using Open software, so maybe you think I can't do this much thing anymore, but if you've separated the concept from the software, at least you know the concept and you know you've got choices.
Yeah, absolutely.
I think it's very true. Separating concept from the software is key where possible, and I think perhaps we don't always do a good job of that. And here I am speaking as an industry, I think sometimes we have, I've been to conversations where people have said I need to use MATLAB, can you help me with MATLAB? But it turned out they wanted to know how to do it and solve a differential equation. They didn't want to do MATLAB, they just wanted to solve a numeric equation, they just did not know that that's what they were doing.
This portion of Talk Python Enemy is brought to you by the compiler podcast from Red Hat. Just like you, I'm a big fan of podcasts and I'm happy to share a new one from a highly respected and open source company, compiler and original podcast from Red Hat. With more and more of us working.
From home, it's important to keep our.
Human connection with technology. With compiler, you'll do just that. The compiler podcast unravels industry topics, trends and things you've always wanted to know about tech through interviews with people who know it best. These conversations include answering big questions like what is technical debt, what are hiring managers actually looking for? And do you have to know how to code to get started in Open Source? I was a guest on Red Hat's previous podcast, command line Heroes and Compiler follows along in that excellent and polished style we came to expect from that show. I just listened to episode twelve of Compiler how should we handle failure? I really valued their conversation about making space for developers to fail so that they can learn and grow without fear of making mistakes or taking down the production website. It's a conversation we can all relate to, I'm sure. Listen to an episode of Compiler by visiting Talk Python Fmcompiler. The link is in your podcast players show notes. You can listen to compiler on Apple podcast, overcast Spotify podcast or anywhere you listen to your podcast. And yes, of course you could subscribe.
By just searching for it in your podcast player, but do so by following.
Talk Python Fmcompiler so that they know that you came from Talk Python to me. My thanks to the compiler podcast for keeping this podcast going strong.
We can dive into the applied math aspects, but I think one other final thing on this is I feel like professors, especially as they get older. They've taught a certain way with a certain set of tools for 20 years. And you know what? That course they wrote, they already have the materials and exercises and all of that. And the idea of saying, we're going to now throw out this and grab some new open source library, I mean, there's 350,000 libraries on pipe, and they're always changing and churning, and something new is coming along. And it's maybe a lot to ask, but also maybe not too much to ask to say, look, you should keep up with these things. And if there's a new way to present it to your students, not because even some of the ethics stuff, but you might be doing a disservice to your student to say, look, the only way that you can solve these problems is with, say, fortran, or the only way you can do it is a $2,000 toolbox extension to MATLAB. That's the way that you have to go to solve this. And here's this super well respected professor telling you that's how you do it. Well, that's not actually how you do it. That's how they've done it for 20 years. And so there's a lot of immersive measure there. Right.
I'm really nervous being electra, so maybe I'm being really naive here, but it is an effort to keep up with all this stuff. But that's our job. Our job is to keep up with the latest marks. Anyway, if in 30 years time I was still using the same marks as I'm using today, I wouldn't be doing my job properly. So why is the same software?
I think it actually, frankly, comes back to ethics in that it's unethical to not make the effort to update your training. And if we're talking about doctors and surgeons, they do need to learn new things as the science evolves. I think probably with lectures, professors, higher education, it comes back to that dichotomy between research and teaching and how teaching is viewed. But yes, absolutely. I think in a way, I would be disappointed if at the end of my career, I'm still teaching Python, in a way. Also open house.
Not 2020 Python, but 2050 Python, or whatever it is.
Exactly. Or Pythons I've started teaching Python, too.
Or Python Plumbing.
I have to figure out how to teach both. Yeah, exactly.
Yeah. Sorry. So you started teaching Python Two, and then now you've had to figure out.
How to deal with Python Two and three, and now I just need three.
I can't believe that transition took so long. But, well, there it is. Let's dive into some of the problems. And more specifically, I'm going to take this book that you all created and use it to sort of guide our exploration of both some of these problems, how we might solve them with Python, and some of the libraries that make it possible. I guess one of the things that struck me about that journey is that there's not that many external packages that are required. It's not like, well, this one takes ten to solve this problem, this one takes these complex, these five. If you put them together just right, you get the answer. So that'll be fun. But tell us a bit about this book. Applied Mathematics with Open Source Software.
So publisher, academic publisher, which amongst other things, means the book is really too expensive, but they also just send out emails to people saying, hey, could you write a book? It's not necessarily a source of flattery, but got one of the emails and Garrett actually had just given a talk at Icon UK. I don't know if you want to say a little bit about the talk you gave.
It was very much a precursor to this book, where I had given an introduction to the field of operational research, which is how we label this certain type of applied mathematics and all the different problems that could occur. And I think the title of the talk was there's a library for that, because every sort of problem that we could come up with, you could pip install a library and in a functional to solve problem, which is a neat there is a neat little method.
If I could just interrupt the call for proposals for PyCon UK closed on Saturday, so if you think you go, please submit a thought.
Yeah, it was just really neat that we had these what we call standard problems. It was essentially our Horse graduate MSC course that we teach. But instead of teaching the maths, there was one or two Python functions that solved a few, and then yeah, that eventually evolved into this book, where instead of each little topic being a couple of functions, we filled out chapters on some of the theory and again tried to separate the maths and the programming, emphasizing that by introducing another language, which is R, to show that you can do it in two different ways and the software is independent of the problem.
I think you and I described it because every now and then as we were writing the book, we kind of stopped and go, wait, who's the book for? And as we were making decisions about how exactly to do something, we're like, wait, what's the book for? I won't necessarily well, maybe we should talk about that. But I think we've kind of written a book that's meant to be useful to people wanting to get started either with the mathematical field problem or with how to actually do it with the code. And so every chapter has got the same kind of structure that describes a problem, then it describes the basic ideas between the theory of the problem or the mathematical tools, the theory behind the mathematical pools. But again, not going into too much depth, kind of what I said before about you don't need to understand all of mutant enlightened calculus to be able to kind of predict the outcome of a pandemic, and then it just solves the problem, the original problem. It solves it in two separate ways using R and python. And the final kind of section, every chapter is pointing out a bunch of literature on it, which we thought would be useful.
Yeah. More broadly, you might be able to do these types of problems appear, what you might be able to do with it. Yeah.
But the really cool stuff with the publisher is that we had an ongoing kind of conversation before the start. Garrett and I were both like, well, the book has to be open. They agreed. Like, there's not a PDF floating around online of the book, but all the source files are there. So all the late deck files are there. All the Jupiter notebooks are there with the code. Hasn't quite gotten all the R market down files up yet, but they are theoretically all there. And so the book is very open, which we're happy about.
Yeah. That's great. It is very shiny new. It still has that new book smell. It was released just almost exactly a month ago, right?
That's right. That's right. Keep on saying I've got to have Guarantor over to celebrate, but we don't get around to doing that.
I had to sign a copy for my nun.
That's very sweet.
All right, now, before we dive into the various problems in the python side, while we're still kind of talking a little bit high level, one of the interesting aspects here is the python and R aspect when you go through each chapter, which is I think I agree with you that it's pretty approachable. Even if you don't have to have a masters in math or specialize in that area for it to make sense. It doesn't have a ton of formulas. Yeah, it's not super intense.
I think that's our first official review. Michael. Pretty approachable. It's fantastic to hear.
Like I said, my math while I study Rusted. It was pretty approachable for me, so there's that. But maybe just talk about putting R and python side by side for solving a set of different problems. What are some of the takeaways either of you got from that?
One thing we wanted to do here? Because we would well, I would certainly describe myself as a python person. Non R person. I know R, I writer. I've written a book in R. But I would certainly describe myself as a python person in that if you're going.
To sit down and write something, you would pick python.
I would pick python, exactly. But also, I'm embedded in the python community. I listen to some good python podcasts. I'm a python person, and I can look at some python code and the Joyce. That looks very pythonic. Right? I can tell you that. And so we were kind of aware that we didn't want to translate the python. Two R when we were writing this, we wanted to write this as close to our people as we could. I don't know if we managed that, but that was something as well that we aware of. It's not just translating languages guaranteed.
Yeah.
In Python, we have the word Pythonic for idiomatic Python. Is there a word for that in R or is it just idiomatic R?
I don't know.
Yeah, I don't either.
Yeah.
You're going to say something here?
I was going to say, as we were writing the book, we noticed that there were certain problems which they are in the Python lined up exactly. Not from design, just from if we were going to force these independently, it is pretty much exactly the same way to solve it. There were some problems where we had to reformulate the mathematics because the way to do it in R was so different to the way you do it in Python. That doesn't mean the maths changed. We just had to reformulate and RECOMBINATE it so that we could write it down in R. And then there were some problems again where we had to use different mathematics to solve it in Python and R, because of the availability of libraries and stuff, I thought that was really neat. And I think that emphasizes, again, the separation of concept to software, because sometimes you did have to do very different things in different softwares.
My favorite chapter on this is the one that is your specialty, Darren, the discrete event simulation chapter where I forget the name of the two theoretical ideas about discrete event simulation process based on.
What dealer process based, and there's the event scheduling approach. There's two different ways of approaching discrete event simulation, and the standard library in R to do it is process based. And I don't call it the way to do it in Python, but the way we've said in Python to do it is by using the CIW library.
The only reason Garrett doesn't want to say it's the way to do it in Python is because it's using his library, the library that he's maintain our own.
Yeah, nice.
Both those libraries. I'm pretty sure that underneath well, I know how code works underneath, but the Simmer, which is the R version, I'm pretty sure underneath they work very similarly. There's not many ways you could do different ways of discrete ventilation, but the way you formulate the problem is very different. And going through that in the book and going in Python, you have to take an overhead world view where you look at the system, whereas in you have to put yourself mind in the sorry. Put yourself in the mind of the customer and go, what is the customer doing right now? Rather than from a systems point of view in order to formulate the problem before you could just then go and solve it. I just thought it was very interesting that the way to do it. Each language was so different, and yet probably underneath it's doing exactly the same thing. You get the same answers out. You just got formal.
Yeah, I think that's such a nice example where diversity and I'm using diversity from the way that languages do things, I think that's the best chapter in the book. Frankly, I think that's the best chapter in the book because you not only do things differently from a programming point of view, but because you do things differently from a programming point of view. Theoretical discussion allows you to kind of give a really good understanding of these two ways of doing it. Yeah, something else that's kind of worth mentioning about the Python in our bit. I don't know if this is a terrible address, but I like tests. I don't like trusting in any code. I like writing tests all the time. And we gave this media thing that we wanted the book to be tested. We want to know the code is correct in the book, but we wanted to have these two different languages and we didn't want to kind of use the standard doc test notation for the Python. And then we want to find something that works. We are, et cetera. So we actually wrote a little language Agnostic doctester that basically runs through and tests all the code in the book for us. And theoretically, when you write the second edition, when you add Julia as well, it will be up to hell.
Yeah, I guess Julia is another option that could have possibly shown up in here. Pretty interesting. I guess it's worth pulling this up. It's probably worth pulling up the stack overflow friends and you're putting those in there.
So we have R.
I don't know where these all lie right now, but I would imagine that the graph looks a little bit different across these. Just for people listening, I would say ours is certainly growing. It's actually growing pretty helpfully in many programming languages. And it's not going crazy, but it's going across. You've got Python, which if anyone has looked in the last couple of years, it's just done insane stuff in terms of popularity over there. So there's that. And then Julia is I can't really read it not quite the same scale. Zero 1% versus say, like 2% for Julia, for R excuse me. And then for 16% for Python, there is something to be considered about choosing not just a language, because the language has a cool way of doing Async, or its generators are beautiful, but choosing a language for its ecosystem as well. And that's what it takes on this here. Right.
But also for the community that's already there, I think at least in the area of mathematics. That me and Vincent. I think R and Python are quite prevalent, but they're also used in different.
Maybe their peers there, right?
Yeah.
A little closer than this would, I think.
They're also used in different ways. Would you agree, Vince? I would say Pythons vary because of pipe things like out of the box, there's one library to do this, and it's the way to do it. Whereas with our people tend to write their own stuff and then upload it to crown.
Yeah.
So you might get lots and lots of different ways of doing the same thing, but each one might specialize slightly in a different way.
Whereas with Python, I feel like there's one library that does it really well. I think people just use the ecosystems a different way.
This portion of Talk Python to me is brought to you by the Python at Scale Summit. The Python at Scale Summit is a conference to highlight innovative big data solutions for Python developers and enterprises. You'll learn about trends in the Python big data ecosystem, share stories about implementing solutions, find out about new innovations, and connect with other data scientists using Python. The Python at Scale Summit will be a hybrid conference with talks, workshops, and training. Of course, there will be networking and social events to connect with other Python professionals, too.
Come here. Speakers like Matt Rockland from Coil, ryan Granger from AWS, and many others from amazing organizations such as NASA, Capital One and BCG. Get back together with your peers and learn how they're scaling their computation and data analysis using Python and the Data Science Stack. Register at talk python. FM Python at Scale. When you visit the link, be sure to use the code Talk Python All caps to get 15% off your tickets. That's Code Talkpython at talkpython fmponitzcale, the links in your podcast player Show Notes. Thanks to the Summit for supporting the podcast.
Yes, both those two things are often talked as a strength of either library. Right. The fact that Python has that one way to do things, and then the seven different ways to do string formatting conversation comes up.
The fact that R is kind of like closer to the science, I don't know if that's even accurate, but that's the feeling, I guess, is also a strength. Right.
Yeah. The reason there's lots and lots of libraries to do the same thing is because they've specialized in something which a new academic has just written a paper on, and that's why there's lots of different ways of doing it.
Yeah, all right, sure. Maybe like out in the audience, the ninja says, ours is really powerful when it comes to things like analytics and so on. Right. So maybe there's certain areas where there's the libraries you can pick there's definitely better. Okay. Now, we talked about the book. The book also, as you pointed out, has an open version where you can find it on GitHub, which obviously will link to. And in here, for each one of these, you've got some examples which are basically, at least for the Python side, that you put a notebook examples here. So I thought maybe we could sort of talk through a little bit what is the problem and then maybe really first quick quickly introduce what this area is and then we can then talk about the example problem you put out there and some of the libraries and techniques there.
Sure. So the chapter two which you're looking at right there is about a mathematical idea called concept called markup change. It's probability model that you loosely go that as the system changes over time the system is in a particular state and then you go with a given probability of being in that state to another state. You can go around like that. That's not the best explanation I've ever given, I've explained that many times, that's probably one of my worst explanation. But market change can be used to model queues and there's a whole field of mathematics called queuing theory and that is often used as a very applied problem. The problem we got here is imagine you've got a barber. The barber has kind of two decisions how many chairs they have to cut hair in and how many chairs they have to keep people waiting for a chair. And obviously that has an impact on the queue of how long people have to wait to get their hair cut. And you can use market chains to build up a model and find the probability of having to wait relatively simply. I don't guarantee what I just said.
No.
Yeah. So I think the model then would be the second state and the probabilities of going between each state from the state you're in and that can be written as a matrix. And the neat thing then is there's loads and loads of linear algebra techniques which at this point you don't really need to know about, but there are linear algebra techniques which stuff like numb I can just do for you, which if you know which techniques to use, you know how to interpret that as a real life interpretation. So for example, there's one certain set of equations you can solve using the mark of a chain. So using our matrix which will give you the long run probabilities of being in each state, there's another linear algebraic technique which will give you something else. And that's what this is.
Nice.
Yeah. The problem is essentially comes down to solving a matrix equation which you can write down and understand with basic mathematical knowledge and then that can be solved. This goes back to what you told in high school, that matrices are great because computers can do it fast, but then you directly get to do that, you just write down equations but it's just a cool to nonprice then alge library just solve it immediately for you.
It's amazing. Yeah. So the problem here to make this applied or more operational, I guess, that you all put out there says you have a barber shop and the shop notices that there's a lot of customers who are they come and the shop is full and the waiting room is full, and people just leave. And since covet, I've just decided I'm cutting my own hair. I can't take too long to find a barber or anything that worked. And then after that, I kind of figured out but there used to be this place that I would go to and boy, did it need this problem. It would be you would go there and be like an hour and a half wait and all the time, and you never knew. So they would solve it by giving away free beer to people while they wait, which was nice, but this one was to solve it more in a more formal business way, where they would have people just wait less. So it says you have two barber chairs, there's room for four people in the waiting room. There's about ten customers an hour, and it takes about 15 minutes to serve a customer. How can we minimize or how do we change things so that we don't have customers leaving? Because they come in, see a full waiting room, and take off, right.
Instead of knocking down a wall and building a bigger waiting room or spending a lot of money on an extra garbage chair and just seeing the effect, and maybe five years later, trying the other way, you can just mathematically model this. And this is a good example of, I think, what we described as applied mathematics. You can answer these cool questions.
So you could say, well, maybe we need a bigger waiting room or maybe we need more barber chairs or something like that, right? And then you can make that trade off.
Yeah.
So let me find the this is the NumPy lynn Alexmagic and so basically you set it up so that you set up all these scenarios in these constraints, and then you just say, no, pi solve it, right?
That's pretty much it, mathematically. You write down this matrix, A and another vector, B, and you're solving an equation. Ax equals B. Most of the code is just getting the matrix set up and the B set up. Actually, most of the code is the doc strings. And then, yeah, you just use the least squares. That's one of many ways you can do it. Lee squares is actually getting an approximate solution to linear algebraic equation. And there's various reasons why that's a better idea than solving it directly. And yes, it's basically one line.
I think one of the neat things about this there is all that maths you sort of learn in school or even first year university, where you're doing sort of row operations and stuff. That's not the mathematics that matters here. The mathematics that matters is what is the matrix? You need to do that too. And once you've done it, how would you interpret the result that is the mathematics? It's not the actual operations that you spend so long doing in first year university?
Yes, that is a bit ironic.
That's such a good point, Gary, because I think what is mathematics is an interesting question. Right. And is it being able to differentiate a whole bunch of quadratics really fast, or is it knowing which quadratic you need to differentiate? Right. And I would argue that it is apt. It's really knowing what the problem is. So that okay, then the actual specific mathematical technique, who cares?
Right, sure. Well, Vince, people so often say, I'm never going to use that. I'm never going to do these things. I could do that with a calculator or I could do that. I think a lot of that might be slightly misplaced. I'm not going to say it misplaced, but somewhat misplaced. Focus on some of these things. Right. Like, if you could say, well, spend a little time showing how to differentiate, then we'll show you how to actually solve problems with that, instead of just getting more and more complicated techniques that you can apply.
Integrations, more of a pick and choose where I like to find which thing applies. But still instead of going deep, deep into that on the first year stuff.
Yeah. You had someone on the show a little while ago called Alan Downey. He writes a lot of really great books. And I remember what he said on your show was about he likes to think of teaching these things in the other way. That code allows you to do these things immediately instead of waiting through and waiting and having to have faith that there's going to be used to it. You can just flip that around and understand what it is. I think there's also a lot of that and what we should be doing.
Yeah, that's a very good point. I totally agree. All right, wrap this one up. You were able to find that it would be better to increase the number of barbers by one than increase the waiting room capacity by two, because I think the chance of the shop being full is like 23%, if you had something like that.
Yeah.
Versus 8%, those kinds of things. And those are really concrete numbers that you could go to a business and say, you hired us to analyze these things. We gather all the necessary information, like average time, how much that might vary, and those kinds of things. And here are your choices, and here are what are the rough expected outcomes. That's really valuable information. And I am very sure that most barber shops, even chains, don't do this kind of analysis.
Algebra barber shops. That's a bold claim.
I know.
And this question a lot of the research Darren and I do is within healthcare. So we work with hospitals solving essentially very similar problems to the one that we've just discussed. We are keen to avoid too much health care because that's what we do so much of. But, yeah, if you get rid of the idea of a barber shop. You talk about a ward. How many beds are on the ward? How big is the parking lot for ammonia's to weigh in, et cetera, et cetera. That becomes very important and very powerful and not something you need to spend thousands of pounds or dollars on licenses for, not necessarily even have a huge understanding of the mathematics. It's all right. It's all right there. Available for anyone.
Yeah. But there's way more at stake in hospital and health care than there is for, of course, a haircut. Okay, let's go on to the next one. So the next topic is discrete events. So I'll find my way over to that one, and you'll introduce this one to discrete event simulation. This sounds like this might be somewhat in your wheelhouse. All right.
Yeah. So I think discrete event simulation is probably if you use the program, and this is probably the one that probably makes the most sense because it's moving virtual things around the place, essentially.
So the question we're asking here is very similar to the question we just answered with Markov chains. But sometimes things are too complicated to be able to formulate the correct matrix, or the matrix doesn't quite work because the situation is a bit too complicated. But what we can do is build a virtual representation of our system. And by sampling random numbers, we can move virtual people around the barber shop and look at what would happen.
Just observe, collect data, crunch that data. And this is what discrete event simulation is. It's building a virtual representation of the system using random numbers to play that virtual representation system and then collect some data about what just happened virtually.
Okay, excellent. So this one let me set the problem that you all laid out here. This is a bicycle repair shop, and there's a set of gates or actions or I guess events, you might say, that it flows through. So a bike arrives randomly at a rate of 15 bikes per hour. They show up, and they say, hey, there's something wrong with my bike. And the staff member looks at it and helps them. It takes about three minutes, but it turns out about 20% of the time, the bikes don't need repair. Did you know that there's a thing to just twist here and tighten it. All right, go away. You're fixed, you're cured. But 80% of the time, there is something wrong flat tire, broken chain, whatever. And that gets put into a place where they're waiting to work on it, and that takes about six minutes, and then you got to collect it back. The question is, I guess the difference that I see here is there's not an uncertainty of whether or not you want a haircut when you show up at a barber shop. There's just the amount of time and where the people are and the actions they might take.
If it's too full.
But here you may show up and you may need help or you may not need help, and so on. Right. Is that the difference?
I suppose that is the difference between these two problems, but that's not the reason we would use simulation over mark of change.
In fact, the situation we're looking at here could be formulated as a mark of chain. The difference I see is that in this situation, you could have an infinite amount of bicycles in your bicycle shop. So if we were to formulate that as a mark of chain, we'd have an infinite matrix, which is not terrible to deal with, but you wouldn't be able to deal with it in the way we just did.
Got it. Okay.
Talking about the states that I did kind of awkwardly in the previous chapter, it's just how many people are in the shop? So there's three people in the shop, but there's a probability that the next thing that happens is four, or the probability that the next thing that happens is two. So it's a very straightforward set of states that is finite as guaranteed here. There's two things to keep track of. There's the number of bikes being seen by waiting to be seen by the inspector, the number of bikes waiting by the repair shop, and that just immediately affected. Now you've got these two dimensions that can change just, again, adds to the complexity and the fact that mount for them.
Yeah. So the reason we would use simulation for this is because it's a more complicated situation for a variety of reasons than what we had before.
It would take a really big, if not infinite matrix to be able to solve this. So why would we go to that effort when we can get quick, easy answers just by virtually playing the system?
The two chapters are paired and actually, all the chapters are paired in the book for the reason that they are kind of the two similar types of problems from opposite angles. And correct me, Darren, if you don't agree, but I think the two opposite angles about numerical tractability, how much you can do with an exact method, which is what the previous chapter was, versus a more approximative method. And it's not always easy to say exactly what you should use one or the other. Sometimes it's absolutely clear, but sometimes it's not. But there are these pairs of chapters that kind of reflect that the size of the problem for what the better one?
Interesting. Okay. The fundamental Python bit here is the C-I-W. Or you pronounce that Q?
Yeah, I call that ku, C-I-W. Ku. It's the Welsh word for koo. K. It's the Welsh word for that. And that's why I called the laboratory.
Fantastic. All right. And so the idea is basically you state the problem in terms of the arrival rate of events, the inspection or the service distributions in terms of how those flow through there, the number of things that can be servicing it and the routing and so on. You create a network with the queue library and then you could just ask it questions. Right. You can tell it to run a simulation.
You can run it for some amount of time, like 8 seconds or so on. And it's interesting that it simulates it, that it doesn't exactly solve it. Right.
Just the point of simulation. No, not the point, but one of the uses of simulation is that we can quite easily simulate something that's too complicated to solve. Exactly. Or would take too long to solve. Exactly. But we can quite easily simulate it. The trade off then is because assimilation is essentially strange around the numbers that we do things too. You could get extreme values, you could get closer. So you lose accuracy, but you gain efficiency.
Yeah. So the idea is you run it over and over and over again with the randomness playing out there. Then you just say, well, what is the most common set of outcomes look like?
Yes, actually.
Yeah, pretty cool. So what did we learn from this one? That we could add an extra inspector at the front or we could add an extra repairer. And what was the better outcome here?
So we were measuring was the maximum amount of time a bicycle spends in the shop. We wanted to get bicycles out as quick as possible. If we added an extra bicycle inspector, we would reduce our time, maximum time in the shop, by quite a lot. But if we added an extra repairer, we'd reduce it, but not quite so much. So we essentially found that the bottleneck was the inspection desk and not the repairing.
How interesting. And I suspect maybe that's not true, but I feel like if I was a business, knowing that would not just help me hire the right person, but I think having an inspector type of person would be easier to get right. You don't have to have as creative a skill set to actually be the mechanic that does the repairs. So that's really valuable. As somebody who runs a bike shop, I will also throw out another statement here. It's probably true. I also suspect bike shops don't employ these techniques, but sure we can.
They can. Well, they can. Now, honestly, I believe larger companies probably would.
Stuff like supermarkets and airports probably would have a team of people behind them doing this, but smaller shops, probably not.
Yeah, gosh, I'm trying to remember the name.
Not always right. Would be a little Canada, I'd say. We certainly know of lots of examples of big entities, companies, things that make very expensive decisions without doing these sorts of investigations.
Yeah, well, you mentioned grocery stores and stuff. I had the folks from Kroger, which I think, if not the largest, one of the largest chains in the US. They have basically an analytics and data science subsidiary called 84 51, and they employ 200 data scientists who do R and Python.
That's awesome.
That's not joking around in terms of where do the bananas go and those types of things, right? You're right. The larger companies definitely invest in that.
It's the interesting thing about what is data science, right? From a data scientist in that are they looking at historic data and identifying things? And I suspect there's no answer to my question here. I suspect different data scientists to get the thing. But when you hear a data science department, that doesn't necessarily mean they're doing this type of work. It might be absolutely, but they might also be diving into the data and understanding and observing as opposed to necessary modeling. Possible.
It could be AI. It could be AI and ML. It could be data ETL, just bringing in data and just getting into system. There's all these different aspects. I wonder more about the data science on when do I go from being somebody that uses, say, Python for computation to becoming a data science? Right. When do I would you cross the boundary from being a mathematician or a biologist to becoming a data scientist that has some understanding of biology, for example?
I would argue it kind of goes back to what you were saying earlier about what is an applied mathematician. At what point are these labels helpful and at what point are they not? Right?
Yeah, exactly.
Audience retention. Yeah. Data science is such a catch all phrase right now. I would agree. Also a buzzword. So if you're looking for a job, it's a good one.
All right, let's go on to another one. We'll get through as many of these as we can, and then we have time for anyway, so those two problem areas were paired together. The next area that you focused on is fairly different with differential equations.
So those two areas that we're just in the books got parts, and it's two chapter. Every part that was in the probabilistic modeling is what we call it, these probabilistic type situations. And here in the Dynamical Systems section, and so, specifically here, we're looking at a problem where differential equations can be used. And we started writing this book before the world changed, before Kobe happens. And I remember coming into our writing sessions. I really enjoyed writing the book. Very glad to have it finished. I enjoyed writing the book. I said to, we need to change this chapter because this chapter, there's a disease going around. I think we call it a cold. Yeah, everyone's caught a cold. In a small community, there's a cost.
Knowing about how to hold right.
Financial costs associated with financial costs, with a possible cure that would double the rate at which you get better from the cure, from the coalpart me. Is it worth financially to get this cure? Was the problem. And, yeah, we're like, should we make this about COBET should we just essentially all the graphs we spent so long looking at that we're on the news all the time. This is it, this is essentially the same thing. Should we make about code? And we decided not to, didn't we guarantee? We decided to just keep it somewhat abstract. But yeah, that's the problem here. And the model is a textbook for one of the textbook model that's often taught when you start learning about systems of differential equations called the sir model. And the sir model has a population in three groups, susceptible people.
Sorry, yvette, I think you're talking about a different chapter.
I am talking about the wrong chapter. Thank you, Garrett. Thank you. Sorry, I went off on one. Thank you. That's the next chapter.
Similar? Yeah, they're similar, very similar.
This one we wrote, you can write down a differential equation that dictates not a system, but just the number of people that are infected over time. And so you can write that down, that differential equation, you can get a solution for it. Sorry. Thank you, Garrett. Thank you.
Yeah, no worries. This one actually uses an interesting library that I am just fascinated with. It's an old school, right?
Yeah.
I just had the folks on back in May not too long ago for this one. Andre and Erin for this, and I did not expect this from Python because I expected NumPy and the linear algebra type things, but not here is the integral of the solution of this differential equation and here are the steps that I took to get there. It is so neat.
Sent by is an incredible library that just gives you so much of what mathematics is thought to have to be commercial in that you can have all your symbolic stuff. So if you want to know what is x plus X, you don't need to tell the computer what value x has with Simply. The computer can just understand the concept that X is this mathematical idea and it's incredible and it's a fantastic, fantastic bible. I think it was when I started teaching programming through our first year cohort I actually told Sage Math and Sage Math is built on top of Simply. But at some point I decided to just teach with Simply and that's what we use here. That's what we use here. We build up the actual numeric solution for the differential equations. We find the expression that if you put it into this differential equation, that would be the solution. We get an exact solution here.
It's pretty wild. You say the way you set it up, everything about senpai is wild, but the way you set it up here is you say, I'm going to create some symbols like time t or constant alpha or so on, or initial conditions, and then you say, I'm going to have a function. You don't say what the function is, you say there's a function called I and then what you define for the thing you're going to work with is you say SIM equation and you say the equation is going to be given the derivative of this function of T and T. And then it has this expression in there, negative. I guess that's probably the what you're specifying here is this is the derivative, not the equation itself, which is negative times IoT. Right.
This is one of those parts of simpa that when we teach this to our first years, it allows us to help identify misunderstandings about the mathematics. I think programming can often help you understand mathematics better and likewise and vice versa. But people often come to study mathematics and don't know the difference between a formula and an equation. And an equation has two sides. An equation has an equal side in the middle. And so what you're creating here is SIM equation. SIM Q takes two variables on the left hand side and the right hand side. That's actually the name of the parameters. So the left hand side is the derivative of i. So it's saying that the speed at which the number of infected people changes over time, that's the left hand side of your equation is equal to and then the right hand side of the equation, some constant alpha minus some constant alpha sorry, times the number. So speed is related to the number and that's really the relationship that defines the whole equation.
Right. And in this scenario you can change the alpha, the rate of recovery by providing medicine or just letting people do their thing naturally.
Recovery, yes.
Yeah, exactly. So in here you say given these constants, we're going to get the equation and then you solve it. You come up with the actual symbolic solution, which is symbolic solution always blows my mind. You say SIM desolve like that solve the differential equation. I've got to give it the equation. And then the initial conditions and stuff and you're like where the initial condition is. We defined a function i. We didn't say what it is, really, but we said at zero it's the initial condition of how many people are sick or whatever that turned out to.
Be, which is just all of which are symbols. Everything here is just an idea. Nothing's a number. Everything is just an idea, a car.
Yeah, we don't know anything about it. We just know these are the constraints of the equation. And out it gives you you get the solution and it is an equation. Let's see, I got to go further down.
So that's it there.
It says it gives you the actual solution and then you start plugging in like the numbers, the different conditions, and it gives you the answers. Right, sorry, exactly.
Yeah. You plug in the numbers at the end.
So we get the cost if you were to purchase the cure would be 700 and the cost without purchasing the cure would be $500. Just the overall costing into account productivity offsetting all the impacts of similar types of decisions that governments all over the world will be making. And in this particular case, for this cold, jetter is melted. It is not worth getting good care.
Don't tell that to the people who are suffering with a fever.
It's a cold.
Cold. This is a cold.
Yeah.
We found this chapter really neat because when we started doing exactly the same thing, going, how do we solve this in R? We realized we had to use a completely different approach, a bad phrase.
We were looking at R for an equivalent symbolic mathematics package in R, and there is one, but really it's a wrapper for Python's Simpy. And so we found ourselves writing strings of Python that you pass to R that R passes to Simpy.
Sorry, I think this is your point.
That doesn't sound like really like solving it in R. Exactly.
Yeah.
So we decided we're not if we were just to solve this in R, how would you do it? And as there is no symbolic library, a library for doing symbolic mathematics in R, we solved it numerically. And that just shows, like, exactly the same problem. We get exactly the same answers out, but the bit in the middle, the solution steps were completely different in both Python and R for those reasons, which I think is really neat. I think that shows that you're concentrating on the problem rather than the solution steps.
Absolutely. And what you've learned here is that this function that expresses the cost of people being sick, if T that we talked about is 100 for 100 people sick E to the negative alpha of T, which is pretty awesome. I mean, there's almost always a reason to marvel at the number E. Have you all read the book E the Story of a Number? Have I mentioned this before?
I don't think I have, no.
This book is so good. It just goes back to is it good?
I totally can recommend it so people can check that out if there e.
Is a ridiculously cool number, right? In terms of I know Pi gets all the press, but E is a ridiculously cool number.
It's way cooler than Pi is cool. But if you are into the change of anything, differential equations, integrations, there's nothing like it.
Innovation.
I had not heard about that.
We are going pretty long on time here, so I want to be respectful of your all the time and everything. So maybe is there any other problems or areas or libraries that you make? Actually, let me pick one here. Which chapter is the Game theory? One seven or nine? Let's see.
Wait for it. No, the one before that.
Wasn't before that. Yeah, got it. The missing one is a linear programming one. All right. Game Theory. And the reason I want to pull this up is we talked about Q Grant's library and his application. How about some Nash pie? I mean, there was John Nash won the Nobel Prize in Economics for coming up with basically proving in every game there was an equilibrium position, which is insane. That that's true.
In a 17 page PhD thesis. Yeah. Incredible funds.
Not bad.
So, quick game theory. What is it? People maybe have heard of it, but they don't really know. Or maybe they do know.
I fumbled through the previous one, Gary, but only makes sense for me to take.
Yeah, she should.
So game theory is the study of emergent interactions.
If you can kind of make some decisions, describe a system at the lower level, how individuals interact, what happens at the higher level? That's the study of game theory. It's indirect of decision making a lot of the time. You could think of decision making, for example, with that barber shop problem we discussed at the first stage of, well, if I had this many chairs or this much waiting room, what's the best thing for me? But the only thing that your decision gets hit back with, if you think of a game of tennis, it's playing against the wall. It's playing with that. Probability game theory is just taking it to a slightly different dimension where you have two Barbershops. What if you have two Barbershops, and if one does this and the other does that, where the customer is going to go is the kind of idea right.
Both Barbershops could, say, expand their waiting room. Both barbershops could hire more Barbers, or one could say, if you hire Barbers, I'm getting a bigger waiting room. It's like that trade off.
Yeah, exactly. A very famous problem in game there is the prisoner's Dilemma. Two criminals are convicted and are separated and questioned, and they can give evidence about the other prisoner. If they both stay quiet, they both give no evidence. The police won't have enough evidence to send them to prison for a very long time. They'll have to stay for a very short amount of time. So that's in their interest. But the police offer me a deal, and if I give evidence about Garrett, then I'll go free, and Garrett will go to prison for far longer. Garrant gets offered the same deal, and that immediately creates a dilemma that we will both end up going for a long time. You'll both give evidence, one about the other. And so that's a very simple model. And that's actually what I came on the show a long time ago to talk about, was that actual model and all the interesting stuff to do with that. But this game theoretic chapter is paired with another chapter called Agent Based Modeling. It's, again, one of those points where labeling is interesting because for some, agent based modeling is a subset of game theory. No way it really matter. And this chapter is all about emerging behavior. If we can define how decision makers in our system interact what happens based on what they do and they be plural, then what is the emergent behavior that you can measure? And so the game that we model in this chapter is there are two taxi firms that serve a community, again a small town and they get to decide how many taxis they're going to have. And the town wants to incentivize these two taxi firms essentially not to collude. They want to incentivize the taxi firms to give better service to the population. And so we create the game that allows the tax firms to decide how many taxis they're going to have, one, two or three. And we a little model that describes what happens if each tax firm has one taxi. What happens if one has one, the other has two? What happens if one has one, the other has three, et cetera, et cetera. And then we obtain what is called the Nash Equilibrium, which is a measure of if both tax terms know all this and act rationally, what would we expect to happen?
It's just amazing how these outcomes, it's just so clear what's the likelihood of the other person doing or the other player participant taking this particular choice. And if I take this choice, what are they most likely to do and where things going to settle in. It's really neat how this all sets up here. Let me find this section.
Yeah. So what you do is you create an umpireray that represents one of the participants outcomes and choices. This one, I guess it's a, what is this a zero sum game?
Because you're zero sum. It's symmetric.
That's symmetric. Okay, pass in the transpose of that which says here's the other player. They get basically the opposite of that. And then you just say Nash game and off you go. Right?
Yeah. Nash dot game creates this game. It creates the game object and then the game object. The NASCAR library has all sorts of different algorithms that could be used. And the one where we use is something called support integration which is essentially the basic by definition idea. The thing that we do here is we say, okay, if we are the town hall trying to decide how to let these two tax firms compete is we essentially are deciding not how we regulate them, but how we incentivize them. So one game should we make the two taxi firms play? And we do that by essentially say, I guess we will tax you slightly less if you put on this amount taxis or give you an extra bonus if not. And the idea is to what is the smallest amount that the city hall has to kind of guarantee the taxi firms to ensure that their rapid behavior would be to give that service to the population. Okay. So yeah, and it's just that those three lines are going right there. So while loop where it just increments that offset.
Yeah. And you just say get the equilibrium from it and off it goes. Yeah. Very nice. Okay, this is really great. And I guess it's worth pointing out I've heard of the guy.
Yeah, that's me. I should say that on this project, Nashville Library is myself and former undergraduate, actually. They went on to start the PC at the School of Mathematics. We started this library. It's grown quite nicely now, to be honest. Probably the part of the library I'm the most proud of is the documentation. There's arguably a Game Theory textbook in there, if anyone's interested, as well as all the functionality for two play games.
Yeah, fantastic. Yeah, it looks really great. I'm a big fan of Game Theory. I think it's very simple, and yet it reveals pretty amazing answers and behavior, as opposed to something like partial differential equation, which can also reveal amazing answers. But the journey to get through it is extremely long versus this. You could sit down an afternoon and explain it to somebody like that. Prisoners Dilemma and so on. We could all kind of relate to a lot of what's happening there.
You realize that you're aging. But I remember when I first started teaching Game Theory, everyone had seen the movie A Beautiful Mind, but if the people listening and haven't, or this slightly interested in Game Theory and haven't seen A Beautiful Mind, I definitely recommend it.
It's a Hollywood movie, so have the correct level of expectation. It's a really nice movie. It's russell Crowe plays Jonathan At, not necessarily about the mathematics, but more about his life, which is incredibly interesting. And there's a couple of scenes in that movie that arguably, if you just spend a little bit of time for a couple of seats to that movie, you could explain both to the Game Theory.
Absolutely. All right, well, I get the sense for a tad bit over time, which is fine, but maybe we should wrap it up here. There's a bunch of other areas that we haven't covered that are lots of fun that you go into. So, yeah, very neat. But let's kind of wrap it up. Maybe we'll ask you the final two questions.
I want to thank you for having us, but I know that you got these two questions like, do I thank you now? Do I thank you later? But no, I just.
Yeah, you're very welcome. It's been great to talk about it. All right, now, maybe lightning round. Vince, if you're going to write some Python code, what editor are you using these days?
I use Vin.
Right on. Brent?
I use Supply. I really like having no features. I just like typing. I don't want features.
Right on.
Perfect. And then notable pipes that you come across that you're thinking is worth giving a shout out to.
I was thinking about this before, and the one I'm going to suggest is one called Python Turner. You got it on the screen there yeah. Python terry is a library for plotting on simplexes so for plotting on triangles, want the better word? Type of plots. You draw a lot in evolutionary gate theory as well as other things actually collaborator on that maintains this is a a very nice library for plotting different looking plots.
I'm sure people think about, well, you could have these different plots on triangle surfaces, or how much are you, how close are these three different states? Or something like that. Some of these are really amazing. Like this M cherry one on there where it's got kind of crawling graphs through these triangle, different states and so on. I haven't seen anyone like that before.
It's very cool. And it's built on top of map plot lib. So it's essentially the layer to do all the correct scaling and things like that is there for you. So yeah. Python itinerary is really cool.
Yeah. Fantastic.
Grant I think the library I would choose is called Traces. It's a small library. I don't know if you've ever thought I got a link.
That one.
Yeah. It does one thing and one thing good. It takes moving averages over irregular time intervals. And it was a problem which I thought I had until I found this. And then it just made life easier. I liked it.
Yeah. Very cool.
Okay, I think it's the next link. I think it's below that.
This one right here. Not that one, this one.
There it is.
Yes.
The uneven time series. Yeah. Perfect.
Okay.
Yeah, that's great.
It's just one thing and one thing.
All right. Yeah. And that's often just what you need. But a link to both of those in the show Notes. Thank you so much. So people are interested in your book or maybe exploring some of these problems. What do you tell them? Where do they go?
If you want a book, that's great. I think I'd more kind of emphasize mathematics is so incredibly powerful, and it really is. And it's kind of like I feel that code, open source code. Python kind of order of how important each other are with mathematics really give you superpowers. And so I'd encourage people to investigate those things. And you could do amazing things with mathematics and a bit of code. That would be mine. I don't know what you think.
No, yeah, I second that.
I think my main message is the maths and the software are separate things and they complement each other really well, but they are separate things.
They are separate things. Yeah. That's okay.
Fantastic. All right. Like I said, your book is on GitHub, so people can go poke around some of the examples and some of the notebooks and see what we're talking about. Make it a little more concrete. Make it a little more applied, maybe.
Yes.
Alright, guys, thanks for being here.
Thank you.
Thank you so much for your work. It's been a lot of fun. Thanks very much, Michael.
Thank you.
This has been another episode of Talk Python to me. Thank you to our sponsors. Be sure to check out what they're offering.
It really helps support the show.
Listen to an episode of Compiler, an original podcast from Red Hat Compiler unravels industry topics, trends and things you've always.
Wanted to know about tech through interviews.
With the people who know it best. Subscribe today by following Talk Python FM compiler. Sign up for the Python at Scale conference to connect with your data science colleagues and learn about trends in the Python big data ecosystem, share stories about implementing solutions and find out about innovations in our space. Visit Talk Python FM Python AtScale Python at Scale and use code Talk Python to get 15% off your ticket when.
You level up your Python.
We have one of the largest catalogs of Python video courses over at Talk Python. Our content ranges from true beginners to deeply advanced topics like memory and Async. And best of all, there's not a subscription in site. Check it out for yourself at training python FM. Be sure to subscribe to the show, open your favorite podcast app and search for Python. We should be right at the top. You can also find the itunesfeed, itunes, the Google Play feed at Play, and the Directrssfeed atrssontalkon FM.
We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython FM. YouTube. This is your host, Michael Kennedy. Thanks so much for listening.
I really appreciate it.
Now get out there and write some Python code.
