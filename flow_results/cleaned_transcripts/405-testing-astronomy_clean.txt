So you know about dependencies and testing, right?
If you're going to talk to your database in your app, you have to decide how to approach that with your test.
There are a lot of solid options you might pick from, and they vary by goals.
Do you mock out the DB layer for isolation?
Or do you use a test DB to make it as real as possible?
Or do you even just punt and use the real DB for expediency?
What if your dependency was a huge array of radio telescopes and a rack of hundreds of bespoke servers. That's the challenge on deck for today, where we discuss testing radio astronomy with PyTest and our guest, James Smith. He's a digital signal processing engineer at the South African Radio Astronomy Observatory and has some great stories and tips to share. This is Talk Python to Me, episode 405, recorded February 13th, 2023.
Follow me on Mastodon, where I'm @mkennedy and follow the podcast using @talkpython, both on fosstodon.org. Be careful with impersonating accounts on other instances, there are many. Keep up with the show and listen to over seven years of past episodes at talkpython.fm.
We've started streaming most of our episodes live on YouTube. Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be part of that episode.
This episode of Talk Python to Me is brought to you by Taipy.
They're here to take on the challenge of rapidly transforming a bare algorithm in Python into a full-fledged decision support system.
Check them out at talkpython.fm/taipy and it's brought to you by Sentry.
Don't let those errors go unnoticed.
Use Sentry.
Get started at talkpython.fm/sentry.
James, welcome to Talk Python to Me.
Normally, I talk Python to computers, Michael, but this will be a first.
You are a human, right?
You gotta ask chatGTP about that, we'll see.
There's a lot of people who are interested in talking about Python.
When I first put this podcast together, I thought, "Who's going to be the target audience?" I thought people were really into Python.
People make things like Flask and stuff.
It's kind of a big part of the world.
But there's a ton of people who are scientists, or just curious about programming, who listen as well.
It really surprised me how many people you can talk Python to, They seem to appreciate it.
So it's cool.
- Indeed.
- Yeah, but I also spend a fair amount of time talking Python to computers as well.
Sometimes more fun, sometimes more frustrating.
You never know.
- Yes, we're familiar with that.
- I'm sure, I'm sure.
Well, you have this extra angle of it's not just talking to pure software, right?
That lives in some internet API vacuum, but you have physical things, many, many physical things in radio astronomy and large arrays of telescopes and receivers and as we're gonna talk about, lots of different things.
And I think that's one of the really interesting aspects of this episode to talk to you is Python against real world things out there and real time as well.
- Perhaps sort of to jump back and put the listeners in a bit of context, I work at the South African Radio Astronomy Observatory.
Our sort of primary project is called MeerKAT.
It's a precursor of one of the world's biggest radio telescopes, which is planned.
So the project is called SKA, so it stands for Square Kilometer Array, which refers to the size of the collecting area of the telescope that will eventually be built.
It's in its beginning stages now.
And that has a lot of moving parts, right from the actual antennas that are pointing in into the sky and recording radio emissions from the universe somewhere, through down to the point where a scientist actually sits down with a data product in order to analyze to write his paper that he's hoping to publish and win his Nobel Prize.
And so everything from the beginning of the end there needs some software control.
And Python is the sort of weapon of choice for all of those applications.
- Yeah, it's pretty interesting to see what you're going to talk about.
You gave a couple of presentations at PyCon South Africa, is that right? - Zeday.
- Zeday. - That's right, yes.
Last year. - Yeah, fantastic.
And people, of course, link to those in the show notes and people can check them out.
a lot of cool graphics and stuff there.
The fact that you built this real-time aspect involving Python, which is not normal use perhaps, I think is really something that we're gonna have a good time talking about, as well as just how do you test something like a large receiver array rather than, you know, is the user logged in in the database, yes or no, and let's mock that out, right?
This is both, I think, very similar and yet very different, right?
- Yes, it can be.
And there's a lot that you can do, but there's also some interesting gotchas which we can talk about there.
So, I mean, I don't know where you wanna start.
- Let's get a real quick introduction with you before we get too far down in this topic.
And so tell people how you got into programming and astronomy and all that kind of stuff.
- Well, programming, well, both of those have become, both of those started out as hobbies and they've sort of become my job, which means I don't do them as a hobby anymore, which is always fun.
I was younger in school, I made the mistake during a summer holiday of telling my dad that I was bored. And so he handed me a book and this book was programming in C, I think. I forget exactly.
And being young and naive, I thought this was a great idea and started working my way through it.
So since then, I've been programming more or less continuously. It was sort of the mid to late 2000s that Python started to become more prominent and I picked that up and haven't looked back. Astronomy was also another hobby. In my student days, I spent many South African, cold South African nights looking at the stars. And then a job opportunity opened up at Sareo to do electronic engineering, which was the field that I trained in university.
That was about seven years ago. And so I've been combining these sort of programming and electronic engineering and my astronomy hobby, which has shifted now into radio instead of optical. But yeah, I basically come from that. Fantastic.
I remember getting a book in C, thinking, "Oh, I'm going to learn programming," and then read it like, "Okay, this..." When I was pretty young, I was like, "Okay, this is a little bit much to bite off at the moment," but came back to it as well.
But that's how it was, right?
We used to get books pre-internet, YouTube, and where you just fired up and say, "Teach me programming in the next half hour." - With listings of code and you have to type them in, and then you miss a semicolon somewhere and scratch your head for half a day.
(laughing)
- That's right.
- But I think that was a good preparation, though.
I mean, as great as Python is, it is somewhat high level, and I think it's helpful to have a sort of a, even if you don't often work at that level, to have an understanding of what's going on at a slightly lower level than what the computer is doing.
- It's valuable to have that experience, but I'm also, even though I did it professionally for a couple years, happy that I'm not, I don't have to continuously work at that level, right?
You can just be so more productive in a higher level language like Python, indeed.
- Totally. - Yeah.
So I think you introduced this a little bit, But tell people about SARAO, this project, how'd you get to that place?
Yeah.
Sarao, well, I got there by responding to a job advert and interviewing and what have you.
Sarao sort of started out as a response to the international kind of scientific project to build a square kilometer array telescope.
The idea is to make it the most sensitive radio telescope that has ever been built.
And when you're doing that kind of project, you want to build it in an ideal setting, like optical telescopes, if you want to do proper science, you want to do it far away from cities where there's no light pollution.
Similarly, radio telescopes, you want to do them where there's no radio interference.
So cell phones, TV signals, Wi-Fi, that kind of stuff.
The Southern Hemisphere also has a bit of an advantage in that we can see parts of the galaxy that the Northern Hemisphere can't.
And so, as this project progressed, various sites were identified and ultimately the decision was made to put part of the telescope in South Africa and part of it in Australia.
And Sarao is really the, just the organization around developing the South African part of that telescope.
That's where we are.
- It's a very cool project.
I think a square kilometer array of telescope, that's pretty impressive, right?
And also something that's much easier to do with radio than with optical, I would imagine.
- Yes, when it comes to telescopes, bigger is better, but there reaches a point of where building a bigger one becomes expensive and very difficult.
And so a trick that you can use in radio is called interferometry. So if you measure your radio waves at different points and you measure them in phase with each other or what they call coherently, then you can get away with making a lot of smaller telescopes to build up the same kind of area, which will give you the same effect as a bigger one, but much cheaper because you can do a lot of smaller, cheaper telescopes.
If that in a nutshell is really why these telescope arrays exist, it's very difficult to do that with optical telescopes because the wavelength is so short, the frequency is so high, that getting, getting the, it is possible, it can be done, but getting the signal coherent or in phase is very, very difficult.
- I see.
- That's why we do it in radio.
- Yeah, you don't have much time.
There's not much of a gap between how you've got to coordinate the signals across the radio, but it's even worse in optical, I see.
- Exactly, exactly.
- Nice.
So people who listened to the episode about imaging the black hole, we talked a lot about that.
So, you know, I don't necessarily need to, think we need to cover too much depth about it.
But one thing I think that people might find interesting is, I think, remember from your talk that you said, this is part, some of the work that you're doing is part of the deep space network for communicating with, is that right?
With NASA.
- South African radio astronomy has its origins in the deep space network.
So if you're trying to communicate with spacecraft that are outside of earth orbit, you need a very powerful, or something that looks a bit like a radio telescope in much, except that you're transmitting as well, because you need to be able to talk to the, know, Voyager or your Mars Rover that's out there in space. But very inconveniently for scientific purposes, the earth rotates. So for about a third of the day, if you have a telescope in California, for example, I think is where one of NASA's big ones are, you know, half of the day you can't really talk to your, to your spaceships. And NASA built a network of telescopes around the world and one was in Australia and one was here in South Africa. And some of the early Mars missions were actually used the telescope in South Africa for communication.
But that was, I think in the seventies, I forget my history exactly, but they got a better one in Spain.
And so the one in South Africa was kind of converted into a facility just for science.
And it's been operated by our national research foundation, which evolved into Sarao for the last sort of few years.
And that's what kind of gave us our leg up.
- Yeah, exactly.
It was already built and it was there.
And they're like, you know what?
Instead of just let it, put it on mothballs, why don't you guys do science with it, right?
That's cool.
And we've been using it quite well since then.
They've done, I wouldn't say groundbreaking science.
I don't know that any Nobel prizes have happened, but we have some great radio astronomers, originate from South Africa, that have used data from this telescope.
So, yeah.
- Excellent.
All right, let's talk about first the real-time aspect, this thing that you focus on called the correlator, right?
And maybe give us this side of the story, because I think this alone is pretty interesting, what you've built here with Python, you and your team.
So from a conceptual point of view, in the episode a few weeks ago, when you interviewed Dr. Sarah Asun, I don't know if I'm pronouncing her name correctly, the Event Horizon telescope worked by pointing different telescopes around the world at the same object. Or all radio, shall I say, all radio telescopes arrays, whether they're very long baseline, like what she used, or much shorter, have something called a correlator. And this is the thing that basically combines the signals from the individual telescopes in a way that is, that enables downstream users or scientists to actually make sense of this data. So in order for that to work, the data needs to be in phase, it needs to be coherent. And at very long baselines, they do this by having each station having their very own atomic clock to generate very precise reference signals.
- So as a reminder for people maybe didn't hear that episode is, you know, the earth - Earth is curved, as we all know, hopefully.
And the radio waves come in, and as it hits that sphere, they hit the different parts of the array.
The more spread out it is, even more exaggerated.
But it hits the different parts of the array at different times, so you have to offset those back in the signal to say, well, it came in at this angle, and it came in at this time, and the speed of light says this one is a nanosecond behind that one.
So you gotta figure out how to realign those so it looks like a flat surface that they hit all simultaneously to look like a single picture, right?
So that's basically the job of this thing.
- So partially, you can do the first bit with just with geometry.
We know what the rotation of the earth is.
We know where our different telescopes are.
And so we can calculate roughly what the time difference will be.
The job of the correlator is once you've got those signals and you've applied your sort of rough delay offset to each of those signals, the correlator will find the correlations between the incoming signals simply by multiplying the signals together.
Mathematically is not terribly complicated.
It's really just multiplication of each pair of antennas.
But it's with that, you may remember from your high school mathematics, the trigonometric identity.
When you multiply two sine waves together, you get a somewhat a difference product.
And it's a similar kind of concept, applying to not just to abstract sine waves, but to radio waves that are at various frequencies.
The main engineering challenge is just doing this fast enough for practical purposes.
So in the example of the Event Horizon Telescope with very long baseline interferometry, it's not possible to do it in real time because your individual elements are just too far apart.
You can't get all the data together.
- Not for math, but because the actual data quantity, getting them all back and forth across the world is too hard. - Exactly.
Exactly.
So there's specialized hardware that takes those signals and writes them basically just straight onto hard drives.
Then these hard drives are physically taken to a central location.
I think Sarah did talk about that in her episode.
- Yeah, I think it was Boston and maybe Cambridge and London, something.
- One was in Europe, yes.
- No, it was Max Planck Institute in Germany is what it was, I believe.
- That's right, yeah.
One was in the States, one was in Europe.
- This portion of "Talk Python to Me" is brought to you by Taipy.
Taipy is the next generation open source Python application builder.
With Taipy, you can turn data and AI algorithms into full web apps in no time.
Here's how it works.
You start with a bare algorithm written in Python.
You then use Taipy innovative toolset that enables Python developers to build interactive end-user applications quickly.
There's a visual designer to develop highly interactive GUIs ready for production, and for inbound data streams, you can program against the Taipy Core layer as well.
Taipy Core provides intelligent pipeline management, data caching, and scenario and cycle management facilities.
That's it, you'll have transformed a bare algorithm into a full-fledged decision support system for end-users.
Taipy is pure Python and open source, and you install it with a simple pip install taipy. For large organizations that need fine-grained control and authorization around their data, there is a paid Taipy Enterprise Edition, but the Taipy core and GUI described above is completely free to use. Learn more and get started by visiting talkpython.fm/taipy.
The link's in your show notes. Thank you to Taipy for sponsoring the show.
Yes, and then the same, well, similar equipment does the reverse process. It reads the data off and then it basically batch processes it. This happens in software, so you cross multiply all of the signals together. That's great if you have a limited number of telescopes, up to a few dozen or so, as with the Event Horizon Telescope. In the MeerKAT case, we've got 64 of them and we're building a few more. And as it becomes the full square kilometer array we're going to be talking about hundreds or possibly even thousands of individual telescope elements. So recording everything onto a hard drive at that data rate becomes impractical.
So the approach that we take is we use what we call a real-time correlator. It processes and reduces the data as a sort of first stage in real-time live before recording to the disk and as a part of that step we integrate for a little while. So if you think about it from point of view if you've done some photography at night time you want to do a a long exposure, so you open your camera shutter for a long time to get them all signal.
It's very similar to that.
So we would integrate over, you know, half a second or a second or, you know, eight seconds.
And that gives you a much reduced, there's still a lot of data that comes out of the other side, but it's much, much smaller than if you were recording straight onto hard drives from the telescope, the way that they do in Event Horizon Telescope.
- Right, that is interesting.
I guess it is just like taking a picture, just a different frequency, right?
But same basic idea?
- Exactly, exactly.
- Nice, and so there's a lot of data coming through here.
You talked about how Event Horizon couldn't even ship it around the world quick enough, or even though they were very, very far apart and pretty remote, but there's a lot of data here.
And so maybe give people a sense of the data center.
Excuse me, give people a sense of the data center.
And like, you've got this array of, I don't remember how many of these correlators, server, U1 slices you've got, but it's not just one corner, a PC in the corner, is it?
- No, no.
Although with the way that technology progresses, maybe one day, no. So our current generation Correlator uses an FPGA based computing platform. We call it Scarab. There's a bit of a tradition to name radio astronomy compute things after insects. So the previous generation one was called Roach. This one is called Scarab. They stand for something. Reconfigurable Open Architecture for Computing Hardware, I think was the Roach. And Scarab, the first three letters is ISKA. Yeah, there we go. There's the scarab. And what that is, is an FPGA is a field programmable gate array. So it's a little piece of reconfigurable silicon that has, it's like having a hardware accelerated signal processing. It's very fast and it's wired straight into Ethernet for interconnect. So in our data center in the Karoo in South Africa, we've got about 280 of these individual scarabs and each of them has a role to play in the signal processing pipeline. They talk to each other via Ethernet and they're controlled by a central master controller computer that runs Python. So it uses an asynchronous little routine to coordinate the activities of each of these scarabs. The processing parameters need to be updated from time to time. So for example, as the earth turns, the geometric delay between a given pair of telescopes will change slightly. And so that gets updated periodically in the scarab so that it can carry on processing the data at the full rate that the telescope is taking data in.
So to give you an idea of that, each telescope is producing data at about 35 gigabit per second.
- 35 gigabit a second?
- Yeah, times 64.
- Yeah, that's a lot of data.
- After the processing, the other end of the correlator, so we get about four or five gigabit per second, so that's reduced.
Due to kind of the long exposure effect, it's averaged over a few seconds, so it's four or five gigabits per second out the other end.
And then that gets stored on hard drives for processing and imaging so that scientists can do their science later on.
But that's the initial stage of the signal processing pipeline.
- Yeah, so you've got 64 of these running in concert.
What is uptime in DevOps look like for you all?
Is this continuously 24 hours a day recording or is it offline for a certain number of hours?
- Yes, it is.
And the limiting factor I'm happy to say is usually not the correlator.
We don't need all 280 scarabs to run.
We can run with about 190 of them with full science capability, so there is capacity for spares.
And when you have a system with this many moving parts, there is downtime.
You know, people actually need to go and change the oil in the motors on the telescope and routine maintenance kinds of things like that.
I don't remember our numbers exactly, but I believe it's above 75% of the time that the telescope is busy and doing science.
This is more recent.
It's only in the last sort of few years that the technology platform has become a bit more mature.
In the early stages, it was really still sort of engineering commissioning, but I think we're using above 75% of time now for actual science observations.
- That's pretty impressive for considering all the pieces involved.
And what are these scarabs?
Each one is basically assigned to an individual telescope, part of the array?
- Partially.
So the first one will do what is called channelization.
So it's much easier to operate on narrow signals of, you know, very close to a sine wave.
So the telescope will sample a little bit more than a gigahertz with the bandwidth and that will be chopped up into, you know, a few thousand channels.
Then those channels will get sort of dished out and another scarab later on will cross multiply the corresponding frequency channels from every single telescope together.
So this architecture is called FX.
So first frequency generalization, then cross-correlation, cross-correlation, pardon me, before you get your ultimate, well, product which gets stored in the archive and on which then further science process is done.
- People start to ask questions and draw graphs and things.
- Exactly.
- Yeah, so one of the parts that you employ to make this run fast is, I think you said you use CUDA, CUDA cores on NVIDIA GPUs or something like that.
Is that right?
Do I remember this correctly?
- Yes, that's right.
So the Scarab that you showed on the screen, that's our previous but current generation correlator is working on that platform.
It has its pros and cons.
It's kind of a bespoke piece of hardware.
It is reconfigurable, but there are not that many customers for this particular board.
The problem with doing your own hardware is that it takes a lot of time, particularly if you're an organization that you want to do science.
So for the next expansion of MeerKAT, to build more antennas, we need more processing capability to be able to handle more bandwidth. We've kind of figured out that where they are now, GPUs can do the work. GPUs have actually been powerful enough to do the work for a while now. The problem has actually been the memory bandwidth to actually get your data from your telescope onto your GPU to do the number crunching. So for Scarab, it was very easy. It has some 40 gigabit ethernet and that's wired straight into the FPGA. So there's no operating system taking its time, there's no PCI Express that needs to be negotiated.
The data just comes straight off the network and it can do its processing.
Previously computers were not fast enough to get the numbers on and off the card.
But since PCIE 4 has become a thing and sort of the GeForce RTX 3000 series cards, which we're using PCIE 4, we can do it on GPUs now.
So we haven't deployed one yet.
What I spoke about is the prototype that we've developed.
And that's part Python and part CUDA, right?
Yes, yes. So the CUDA is actually quite small. As I mentioned earlier, the processing is quite quite simple. So there's a stage for channelizing. So that uses a piece of math called a Fourier transform. And there's been years of research gone into that to make it very computationally efficient. It's very fast. The other part is simply multiplying lots of numbers together.
And that's something that GPUs are really, really good at. So we've made good use of technology advances driven by things like AI and machine learning, which relies on really large matrix multiplications. So we just piggyback off of that technology. And the bonus is we don't have to develop our own hardware anymore, which is nice.
And those things are only getting faster, right? If you could have done it on a 3070 or whatever, an NVIDIA 3070, then, you know, it's getting faster and going to get easier and easier as things go. You might need a small power generator to run one of those cards these days. They're kind of insane, but...
The 30 series are a little bit easier than the 40 series. To give you an idea, in our - Our prototype system, we're using 3070 TIs at the moment, and one of those GPUs does the work of four Scarabs.
- Wow.
- So it's the rate that technology moves forward.
To be fair, the Scarab is about six or seven years old.
It was revolutionary at the time, but commercial technology has moved forward a lot.
- Yeah, it sure has.
You talked, just a bit of a sidebar, you talked about one of the challenges being getting the data in and out of the GPUs from a bandwidth perspective.
Do things like systems on a chip in this Apple unified memory where the bandwidth, the memory of the CPU is the memory of the GPU.
Does that, have you guys considered playing with that?
Is that interesting?
- We have had a look.
That's, so Apple's model is something that's not really reached mainstream yet.
And Apple doesn't really sell a computer in a form factor that would be amenable to deployment in a data center environment.
- Yeah, you have to put a bunch of minis on their edge or something, yeah.
- Exactly, yes.
So it's something that we've got an eye on, but we haven't got a usable kind of hardware prototype at this point.
We're currently using AMD EPIC platforms.
They have lots of PCIe lanes and lots of memory channels.
So that lets you get data on and off, you know, from your network to your GPU very quickly.
Advances such as direct memory addressing and other such things, I forget all the terminology now.
But basically, the faster that you can get it off the, into the GPU's RAM so that the GPU can do its thing, the better.
Yeah, it's an interesting trade-off to consider because the GPUs, even in the new higher end Apple stuff, is still quite a bit slower than NVIDIA.
But the memory is instant, so there's, you know, where we have trade-off, cross the line.
It's gonna be interesting as this kind of architecture evolves.
- Yeah, we've definitely got eyes on that, and we'll see how it goes.
- All right, for doing the CUDA stuff, what's the Python side look like?
Is that, what library is she using and stuff?
- So the Python, that's got to kind of do, So the GPUs are very good at crunching numbers, but they're not very good at anything else.
So there's a lot of steps in that for a GPU to be able to do all of those calculations.
You have a high-speed network, 100 gigabit, 200 gigabit, that's very fast.
And so you need software to be able to run your network stack, receive data, and that comes into system RAM.
You need to be able to DMA it into the GPU's memory.
You need to be able to know when the work is finished so that you can copy the data back, packet that up in Ethernet packets again and send it out.
And so there's a lot of things that we use in Python to enable that.
The first and most sort of obvious one would be a library called PyCuda, which allows you to wrap up Cuda functions in a nice Python handle and interact with your GPU in a way that's more amenable to Python code.
There we go, that's the one.
- Yeah, very cool.
- So the other one, the thing that you've got to think about carefully then is coordinating your activities where your GPU is executing, CUDA calls the streams, if you're working in an OpenCL kind of abstraction, it calls it command queues.
So they work almost like threads on a computer.
So you need to have some sort of way of coordinating so that when you start one calculation, you want to make sure that the data is there, that it can work on it.
And similarly, you don't want to start copying it back before the calculation is finished.
So PyCUDA makes this quite easy.
you could use, I think, Nvidia calls it events, but they're basically semaphores and markers to help you to coordinate between your different threads for sending, processing, and receiving data from the GPU.
It's similarly getting it off the network and onto the network again.
- Yeah, PyCuda looks great.
Another thing you spoke about that was pretty interesting is your use of async and await.
Do all the network stuff, which I think is, it's clearly a good choice and fits right here, but I feel like a lot of people don't consider it fast enough or good enough?
Network, but not just that, also the GPU.
You have a few functions and they're running loops.
So the way that we've structured our code, and you can, we've got, I'll share a link with you, there's documentation in Read the Docs as well, explaining this, but we have one loop that just waits for traffic to come in off the network, but bundles it up, and this is kind of one of the trick things you need to do things in batches.
If you involve the Python interpreter, every time a packet hits the NIC, then it'll end up being very slow.
So we have a lower level library written in C++ that batches up a whole chunk in the order of about 100 or 200 megabytes worth of data.
And you use that await keyword to let you know when there's a chunk of data ready.
So when there's a chunk of data ready--
- I see, you wait until enough is buffered up and then you pull it back on the resume or whatever, okay.
- Exactly, so you mark that for upload, you put an event in the stream or the command queue and let that run.
And then in the next, you're using the await, so you're waiting for that event.
And when you see that, you know that the data is uploaded to the GPU.
You trigger the processing, whichever processing task needs to happen, and put another event and then pass it on to the next.
So the third loop waits for that final event.
When it sees it, it knows that the processing is done, and you can initiate the copy of the GPU RAM back to the system.
And then you can transmit that out on the network.
So those two things working in tandem.
- Yeah, I didn't expect the GPU to have this async interface, but it does make a lot of sense.
There's a lot of parallels in a GPU.
- I don't think that it's natively in PyCuda.
I think that's a wrapper that we've done around it.
It's been a little while since I've touched that particular code, but there's no reason that you can't do that at all.
And it's a process that we find has been very, very useful.
- Okay, but your assessment overall is that async and await, pythons, async.io has been a solid choice for this whole platform.
- It's been, I've seen this approach used in other places as well, even since before Async.io has been part of core Python, using things like Flask or Tornado.
So the approach, it's a very good approach.
It's very helpful.
Debugging Async stuff when it goes wrong is a little bit more tricky, but when it works, it works very, very well.
- Yeah, that's for sure.
You get the highs and bugs, keep it in the science space.
Okay, so-- - Exactly.
- Quick audience question, I think is gonna be interesting.
Before we move on to the testing of this whole system.
So out in the audience, Slavik asks, What do you think about simple distributed radio astronomy experiments for like citizen science?
Are they possible?
That's a very good question.
Yes, they are.
It's possible to do amateur radio astronomy using a relatively affordable SDR dongles.
SDR standing for Software Defined Radio.
It's been a little while since I've looked at this, I must confess, as I've mentioned earlier since I do this professionally, I don't bother with it that much anymore.
You have a square kilometer array you're building, you don't worry too much about it.
Exactly.
I've got a big telescope at work.
I don't need a small one at home.
You can do science, it's difficult in most practical cases because most people live in cities where there's a lot of interference.
But it definitely can be done.
One of the fun projects that I've seen has been using a satellite dish like what you would connect to satellite TV, but with a little bit of electronic knowledge and you don't need a degree, you can just be on a hobbyist level to do that.
You can build a square law receiver, so it's very much just is there signal or isn't there, you're not going to be decoding any TV streams.
you can measure, for example, the temperature of the sun using this and you can measure its angular dimensions by simply pointing it and then letting the sun drift through a few times. Yeah, so there are fun projects that can be done. As to say whether it can be useful as citizen science, in other words, useful from a scientific point of view over more than just something interesting to do, I'd have to go and have a look. I'm not 100% sure. It's very difficult to get meaningful results without very, very expensive equipment.
That's why we've got such expensive facilities being built.
This portion of Talk Python to Me is brought to you by Sentry.
How would you like to remove a little stress from your life?
Do you worry that users may be encountering errors, slowdowns, or crashes with your app right now?
Would you even know it until they sent you that support email?
How much better would it be to have the error or performance details immediately sent to you, including the call stack and values of local variables and the active user recorded in the report. With Sentry, this is not only possible, it's simple. In fact, we use Sentry on all the Talk Python web properties. We've actually fixed a bug triggered by a user and had the upgrade ready to roll out as we got the support email. That was a great email to write back. Hey, we already saw your error and have already rolled out the fix. Imagine their surprise.
Surprise and delight your users. Create your Sentry account at talkpython.fm/sentry, And if you sign up with the code Talk Python, all one word, it's good for two free months of Sentry's business plan, which will give you up to 20 times as many monthly events as well as other features.
Create better software, delight your users, and support the podcast.
Visit Talk Python.fm/Sentry and use the coupon code Talk Python.
One thing you did point out, I can't remember which in the two talks it was, but you did say that you can go and rent at least optical telescopes remotely, right?
Yes, most optical telescopes are operated remotely, but a lot of ones that you can, that are commercially available as well, you know, head over to telescopes.com and you can buy ones that can be electronically controlled. And those you can do interesting, is it telescopes or telescope.com? Yeah, that's the one. You can buy ones that are electronically controlled.
Those can actually be useful for citizen science. There's a lot of, for example, astronomy organizations that do regular observations of variable stars or binary stars and they rely a lot on data submitted by amateurs. While any particular observation will not necessarily be that useful, but in aggregate thousands of these observations are very helpful for doing the science that they would be doing then. That could typically be run by university faculty and over, you know, they would aggregate these observations over long periods of time from different locations toâ€¦ Yeah, that sounds like a cool research project.
To draw some scientific conclusions about what's happening with these stars.
- Very neat. - It's a good question though.
Yeah, it is indeed. Thanks.
So let's talk about the testing side.
From my sort of engineering background, one of the sort of key questions that you've got to ask as an engineer is, if you have specifications for a system to build, to design, at what point do you know that it's doing the thing that it's expected to do?
So you've got a certain set of user requirements.
The user needs to be able to have this level of sensitivity and this level of bandwidth and, you know, accuracy.
Less than this much noise or something, yeah?
Exactly, in terms of hard numbers.
So you need to have some sort of way to prove that the system that you've designed and built is going to meet those specifications.
And so testing is a fundamental part of that.
Sometimes you can prove by analysis, you know, just by using maths and showing, you know, this is what the system is designed to do.
But the first prize is if you can run a test and say, "Look, we've got a controlled set of inputs, we can measure the outputs, and we can determine from this that the system is doing what we said it is doing and how well it is." So, you know, what the noise level is or what the sensitivity is, whatever the case is.
And that's something that is often a little bit neglected in scientific projects, particularly astronomy is that's the one that I've got experience with. Other fields I've seen as well, often physicists and astronomers are very, very clever and they're trained in a lot of fields.
They tend to build their own instruments and hardware and write their own software.
It has a kind of amateurish aspect to it sometimes, not universally, but this is the tendency until until it's more or less doing what the researcher wants and then he carries on. So many a software project has been written by a PhD student, he's generated some results and you know published his paper, gotten his PhD. That's very difficult to scrutinize because the code is written by someone and the logic lives in someone's head. And so I'm kind of keen on this concept of testing because I think it adds a level of rigor and transparency to the scientific process because if I've got tests in place then anyone can come along and look at how I've tested my instrument and, you know, criticize or evaluate whether it actually does what I say it does when I publish my research.
So I think the concept is really important.
I do too.
And it's in open source, one of the important signals that people use when they go and look at a package they might consider like PyCuda or Pandas or whatever is, does this thing have tests as part of its design, right?
If I'm going to depend on somebody else's library, or if I'm a maintainer and I create a library and someone's going to send me a PR, how do I know whether their changes that they're suggesting to me broke something I didn't see coming, right?
And having unit tests or some kind of test typically driven with PyTest for Python is a really important, not just supporting pillar of that project, but also a signal to others from the outside.
Like this thing, people care about this.
They've verified it.
They want to keep it strong.
- And it sounds to me like this might also be really important for science in the same way.
You talked about people coming to review your work or to try to reproduce it.
And if they see the test and they can run the test, it communicates something additional rather than just, well, I thought a lot about it and here's my graph.
- Exactly, yes.
We want to do groundbreaking science and we want to be able to say that when we make observations that what we're seeing is real science.
And it's not just some sort of anomaly that we found in the telescope signal chain.
And the presence of good tests helps with that because then we have rigorous testing that we can say, look, this is the performance characteristics of our system.
You know, it gives a little bit of extra confidence in your scientific results that way.
- Indeed, so how does this look different than like testing flask or something, right?
'Cause it's not exactly the same and you maybe are leaning on it a little bit more to communicate more information, not just pass or fail.
There are a few things. In one sense, we do use unit tests in the same way that a lot of open source projects do.
Just, you know, does each individual component of my module do the thing that I've designed it to do?
But if you go a little bit beyond that, the same sort of philosophy and application can be applied to systems as a whole.
If you have a complicated system with a lot of different parts talking to each other, it can be tricky to a change that you make might not break if you look at it in isolation, but do those interfaces still work?
If you're unit testing something, often you mock out whatever's at the end.
So you pretend that you'll get a real response from a website when you do an API call.
But if you've touched the code that actually handles that API call, then your unit test is not going to pick that up.
So we've got a relatively rigorous process for what one might call integration testing.
So an entire system gets set up in a simulated environment, but an input like it might get from a real telescope and the ability to watch their output.
And so we do that on a regular basis.
We spin up an entire correlator in a system in the lab, give it a deterministic input, and so we can measure the output and determine whether or not it meets the criteria.
- Yeah, cool.
Is this like a software emulator in Docker, or is this an actual one of your one you FPGA things that's dedicated to this integration testing?
- It can be both.
It can be both.
So we've used the same approach to testing the old Scarab correlator.
One of the Scarabs can be configured to emulate a telescope so it can produce a signal similar to what a telescope might be, except not having astronomical signals in the data.
it would have a deterministic signal such as, you know, a normal frequency tone or just white noise, depending on what kind of test we want to run on the correlator itself.
You don't replay the wow signal to it?
We could, but it's faster just to generate signals. You're not going to get, with a strongly deterministic signal, in other words, if you know exactly what you're putting in, you can see what you're getting out as well. The wow signal, not as useful for determining the noise level.
Yes, exactly.
More fun, not as useful.
So one of the things you did is you changed some of the output from PyTest to be more representative of talking about how you've met your requirements and stuff.
Maybe tell folks about how that works.
Yeah, that was an interesting exercise.
Serao uses a process called systems engineering, which was developed in Bell Labs, I think in the 40s.
It was quite a while ago, and it's been strongly influenced by the sort of military processes.
And it's people in a software environment would recognize it as like a waterfall pattern where you'd have a big design up front.
So you'd have a lengthy analysis of what the requirements of your system are, and, you know, allocated different performance characteristics to different components.
And once you've done with the design, you need reams and reams of documentation to prove that your design meets the specifications as well.
Graphs, tables, pictures, numbers, all of these kinds of things.
PyTest and other packages, there are other ones, but PyTest is the one that we've used.
It has a much more simple output.
In other words, it'll give you lots of details if something goes wrong.
It'll give you a stack trace, it'll give you debug information of what the variables were at the time that there was a problem or that the assertion didn't meet.
But if everything passes...
It's all green.
Okay, we're good to go.
You got a dot.
Yeah, you know, like, okay, the sensitivity is better than X, but how much better?
And how does that vary with frequency?
kinds of things, what we'd like to know and what we'd like to be able to present to the various stakeholders that are interested in the performance of the telescope. We have a system. Okay. You need to zoom out a little bit there. And I, for those of you who are watching on YouTube, I do apologize for the, it's difficult to put code on a screen in a way that's not going to put your audience to sleep.
Yeah. And I just grabbed this off of your talk just so we had something to like kind of be concrete about. But you have this interesting reporting aspect that runs along with your test for sure.
Yes, so PyTest has a plugin called Report Log and that if you sort of squint at it and look a little bit carefully, it allows you to kind of record metadata as you're going along. So things that are happening in your test. So there's several things happening at once here and maybe if I could just take a step back, this test that you've got up is a test of linearity. So what does that mean is that if I put in a signal x and I get an output y. So if I put in a signal 2x I should get 2y as the output so that they should be directly proportional to the other. And if there's, if they're not, then there's a non-linearity of some sort in the system. No system is perfectly linear so there will be some sort of margin for error. We don't have a specific spec on this particular linearity test. It's a quick one to run because it takes only a few minutes and it can give us a sort of a first eyeball of is, are things working as we expect them to do. PyTest, if for those of you who are not familiar with it, the tests are written in the same syntax as Python functions, except where the inputs of the function are either parameters or fixtures. So parameters can be if there's a parameter space over which your test will run. So in our case, for example, different numbers of frequency channels, different numbers of antennas, this one isn't parameterized, it uses only a few fixtures. The fixtures are things to ensure that you have a test that is reproducible.
So in this case, the correlator fixture gives us a correlator.
It spins up in the test cluster that we've got in our lab, and it gives-- so the typehints there gives you the hint that we're getting a remote control, so that little correlator object there gives us the ability to communicate with it and control it.
The next one is a receiver, so that's--
you know, if a correlator is running, you need to be able to receive what it's outputting so that you can compare it against whatever the spec is.
And the third one is the PDF report.
So the name is a bit of a misnomer.
Initially, I...
So that little fixture is written using module called PyLaTex.
So shout out to the authors of that one.
It's very useful.
And the best way to generate...
You can generate PDFs directly from Python, but it's very low-level and it's difficult.
So we use LaTeX as a kind of intermediate step to do the typesetting and PDF generation for that.
So with that, you can focus on actually just getting the content and then use LaTeX to arrange things and typeset and make sure that there's, you know, the lines wrap over and what have you. Ultimately, the output will be a PDF with a report of the test as it's run. So this is the configuration that we ran, these are the steps that we followed, and these are our results. Version 2 of that uses an intermediate product. So instead of outputting a PDF straight away, we just serialize the data and put it into a little JSON dictionary.
The reason for that is sometimes in LaTeX, you got to tweak your formatting or something like and it would be nice to not have to rerun the entire test just to change the font or update the heading.
And so there's actually an intermediate step and there's another step just later that takes that JSON, pauses it and generates the PDF later.
- Right, well, you can also ask questions about it, right?
You can analyze the test JSON and maybe draw averages over time or here's how much has varied as we've evolved our system, right, not just pass/fail or what did this one look like?
So JSON's pretty good.
- Exactly, when you incorporate this with other CI/CD tools, you get GitHub Actions or Jenkins or whatever the case is, you can do this repeatedly and then you have records of over time, you know, how your system has evolved versus, you know, what changes you've made and it makes it much easier to reason about and, you know, understand the performance of your system and how it changes over time.
- I think that's really neat.
I don't see that being done very often at all.
And I think it's easy to look at this little bit of code that you put up in your presentation and say, oh, okay, well, that's PyTest, and now here's a fixture and so on.
But like, if you think about what those fixtures are doing, one of those fixtures maybe is controlling one of those one-U FPGA machines to set it up, right?
And then the other one is in our, there's a lot of power and stuff going on with these little, you know, here's a variable we call the correlator.
- Exactly, yeah, so you're right.
There is a lot of code hidden behind here, but it's code that you're gonna run every time.
So it doesn't matter what test you're doing, you're gonna wanna spin up a correlator.
and whether it's an FPGA or a GPU, doesn't really matter.
You want to run through the same sort of steps so that your test is repeatable and that the result corresponds to the input that you give it.
And so the PyTest fixtures are great for that because once they allow you to get the boring stuff done, once you're confident that you're doing it right, then you can just keep doing it.
You use the same correlator fixture for every test.
And if there's an update, if something changes, if there's a change to the hardware that you need or the protocol that communicate with them, then you can update it just in one place and all your tests will benefit from that update straight away.
Yeah, it's a very powerful aspect of PyTest.
You've taken it to quite a level here.
One of the things that I kind of wanted to, when I did the talk last year, that I wanted to put forward is that, you know, these concepts of testing, you can apply them to real-world systems as well.
So, if you can talk to it, then you can use PyTest to test it.
If you can talk to it over the network, a serial cable, or, you know, USB or something like that, You can test actual hardware, make it do things, you know, so that you can, you can qualify it.
It doesn't, it's not just restricted to, you know, little toy pieces of software, you know, your flask or your tornado or abstract conceptual things that live in the cloud somewhere.
It can actually translate to real world things.
Yeah.
People say when they talk about tests and stuff, they say, well, look, it is sometimes I say it is your documentation or it is the way you verify things are working.
But when you get to the engineering and the science level, and you're trying to verify physical things and stuff, it's cool to see how far you can push it to maybe even answer that question better, right?
Like with this reporting, for example, over time.
- I think it makes it more transparent as well.
In the open source community, we like to quote Linus' law a lot, we say with enough eyeballs, all bugs are shallow.
But if we're honest with ourselves, like not everyone is gonna go and read the code.
But on the other hand, if you can see a graph of, So this is the frequency response of the system.
That makes it much easier for interested parties to actually interrogate and say, look, you know, is this good or is it lacking in some aspects?
So from that point of view, I think it just increases the transparency and allows not only yourself, but the sort of the general, the wider scientific community to have more confidence in the performance of your telescope.
- Makes it more approachable too, I think.
- Exactly.
- Yeah.
People maybe wouldn't read a unit test and what the heck are they supposed to make out of it anyway?
know, they may well look at a graph that was generated by the unit test, right?
Exactly.
Yeah.
And this is, it's much easier for me to pass as well because, you know, I get to the office in the morning and, you know, the CI run is done overnight and I can see at a glance, you know, are things working the way that they should.
Yeah.
Cool.
What has been the reaction from other scientists and engineers when you talked to them about this?
How's this perceived more broadly?
It's been relatively positive.
Scientists want to know when they can get time on the telescope and then I have to tell them well, there's a committee that evaluates scientific proposals. We can't short circuit that unfortunately.
MeerKAT has gotten a lot of attention from, well, scientists who are interested in radio astronomy, particularly fields like pulsars and another of our sort of clients is possibly the wrong word, but is the project called Breakthrough Listen. If you've heard of SETI, it's the same crowd that are trying to search for extraterrestrial intelligence. Sometimes Sometimes they're interested in these kinds of things, sometimes not.
Often it's a much shorter question of like, "Is it working and can I get some of the data?" If the answer of those two is yes, and they start looking at the data, then you know, this performance figures and test results are sometimes more interesting to them.
But generally, it's quite well received.
- It seems like a cool idea to me.
Do you have, time on telescopes is really precious and rare, hard to come by.
The more powerful the telescope, I imagine the more contention there is for that time.
Is there a bunch of simulation and software and things that people can hand out to these folks that they can work with beforehand so they become more prepared?
Yes, and well, it mostly consists, it depends on what you're interested in.
MeerKAT has an interesting architecture in that there are some of the clients that have hardware right on site that are subscribing to data and processing it in real time and Breakthrough Listen is one of them.
You know, they're interested in very, very fast transient stuff.
Other scientists are more, they're not in as much of a hurry.
They're more interested in the end result, the output of the correlator.
That has been through several stages of pre-processing.
And it depends on what kind of science that they're doing.
And so, as with most telescopes, certainly, but scientific instruments in general, we keep all of the data from observations of past.
Typically there's an embargo on that.
So it could be a period of 12 to 24 months to allow the original originating scientist of the observation enough time to do his analysis and publish his papers.
But once that is lifted, then that data is available to basically anyone who wants to use it.
So all they will need to do is contact us and we can give them access to historical data sets and they can begin to test their algorithms on actual historical observations.
Yeah, that seems good.
Excellent.
All right.
Quick question.
Follow up question here before we kind of wrap things up.
James asks, what happens to the raw data?
Talking about coming out of the correlator.
I suppose received how much of it is captured and stored versus process down and then storing the result.
Okay.
So as I mentioned earlier, each telescope generates data at about 35 gigabits per second.
That is impractical to store.
We have logic on site that will buffer up a few seconds worth of data.
And then they have algorithms that are searching through it for interesting things.
And if there's something that they notice, there's a mechanism to dump that to disk.
So just a few seconds at a time.
And that happens a few times a year.
The generally the most interesting pieces are a little bit more downstream.
So 35 gigabits per second times 64 is a large number.
So that's north of two terabits per second that the antennas themselves generate.
The output of a 64 antenna correlator is about four gigabits per second.
You could ingest that on a Mac mini if you somehow had a USB for two--
- Just somewhere there to keep plugging and unplugging drives really quickly, yeah.
to Ethernet, yeah, you'd need to do it pretty quickly, but that is practical. That we have a storage cluster. So we have one on site in the desert in South Africa, it's relatively small only about five petabytes, but that acts as a cache. And then there is a fiber link to Cape Town where we have a data center with with a much larger archive that uses an object store. I believe it's Ceph, it was also an open source thing. And I'm speaking a little bit outside of my expertise now. But that data is retained in well, so far in perpetuity, we haven't gotten to the stage where we start deleting old data yet.
So we've got all of the observations that we've ever run.
And they range in size. It depends on the observation.
But sometimes they're a few gigabytes and sometimes they're sort of many terabytes in size.
Yeah, it's a lot of data. You wouldn't store the two terabit per second, though.
That's too much.
I don't know what we would do with that.
That's one of the reasons that the correlator exists, to sort of get that down to a manageable, useful level.
Yeah, indeed.
All right. Well, anything else you want to add that we haven't talked about briefly about this testing side of things?
Have we covered it pretty well?
- The one thing that we haven't kind of talked about is we talked a little bit about earlier about how critical the performance of this is.
And one of the things that testing has really enabled is for us to optimize the performance of the system.
And in a way that's, I think, not immediately obvious.
If you have a first naive implementation of your signal processing algorithm, that's easy to read, easy to reason about, it's not likely to be the fastest possible way to process the data.
But it's good to have that.
And then once you have that, then you can write a test for it.
So you can compare a known input to a known output and see if your maths is correct.
That way, when you iterate, perhaps we can change the memory access patterns or, you know, improve the coordination between the threads.
It's very easy when you do that to make a mistake and start messing up your results.
But when you have a unit test and you start messing up results, it can catch it straight away.
So having that testing in place allows us a little bit of, you know, room to experiment to really push this to the limits of what these GPUs are capable of doing in terms of increasing bandwidth or more antennas that we can process or all these kinds of things.
And you mentioned regressions earlier, that's an excellent thing.
So you're working on another part of a system and something breaks, having these tests in place will let you know, "Oh, we've messed something up.
Let's revert back and be a little bit more careful next time." So I think it's just a great concept.
In industry, in science, in academia, everyone would benefit from having more embedded tests in place.
You're not a panacea, you're not gonna anticipate all the possible failure modes in your tests, but it definitely helps catch many of the obvious ones.
- Yeah, good advice.
Testing science is tricky.
It's usually a stream of numbers in some way, it's not, yes, there was a user, no, it came back none, or there was an exception.
It's still shooting out a bunch of numbers.
Are they good?
Maybe they're better, I don't know, right?
But having systems in place to record them, to test them, to say if it matches this curve within some tolerance, it's still good.
- Yes.
- It's really important in those areas because it's so hard to look at it and know what the deal is.
- Exactly.
And I mean, so it is a team effort.
There's not necessarily any one person that's gonna have the experience to do all of these things.
So the person who is a very experienced systems engineer who will know, you know, the methods by which we can evaluate the performance is not necessarily gonna be the best coder.
So that's why we have a large team in order to pull all of these things in.
So yes.
So shout out to my colleagues at Serao.
We're doing good work.
Or at least I like to think we are.
- It sure seems like it.
Cool, all right, well, we're about out of time to talk more about this.
So let me ask you the final two questions before you get out of here.
If you're gonna write some Python code for this crazy big system you've built, what editor do you use?
- I'm a bit old school.
I basically just use Vim.
- Vim, right on.
- I feel most comfortable in the terminal, so no fancy GUIs for me.
- Yeah, there you go.
And then notable PyPI package.
Do you want to give a shout out to?
- Well, a couple of ones that I've already mentioned.
PyTest is very important.
PyCuda has also been critical in our work so far.
So yeah, shout out to those two.
Thanks to the open source community for providing that for us.
- Yeah, it's really cool how much of these general open source projects are supporting science and other types of exploration.
- Cool. - Yeah.
Okay, final call to action.
People are interested in maybe adopting some of your practices.
Maybe they want to learn more about how you did this reporting in PyTest, or even as someone in the audience asks, can they get access, how do they get access to the datasets potentially?
What do you tell them?
- The datasets, well, I hope you have a very big hard drive on your laptop.
If you go to serao.ac.za, there'll be a contact page.
And if you can send us a question and we'll make sure that it gets to the right person.
I'm not sure what the procedure is for access for people outside.
I can get to it when I want to, but then I'm inside the organization.
So start with an email.
- But if you ask the question on our contact page, yeah, and then we'll send you to the right place.
To learn more, I'll put the GitHub link to the software for the correlator.
It's all there and the documentation is relatively good.
If there's something that's missing, you're welcome to just raise an issue on the GitHub repo and then we'll see how we can help.
- Excellent.
Well, thanks for sharing your story and keep up the good work.
- Michael, yeah, thanks very much.
It's been great to be here.
- Yeah, it has been great to talk to you.
See you all later.
- Cheers.
This has been another episode of Talk Python to Me.
Thank you to our sponsors.
Be sure to check out what they're offering.
It really helps support the show.
TypeEye is here to take on the challenge of rapidly transforming a bare algorithm in Python into a full-fledged decision support system for end-users.
Get started with Taipy Core and GUI for free at talkpython.fm/taipy, T-A-I-P-Y.
Take some stress out of your life.
Get notified immediately about errors and performance issues in your web or mobile applications with Sentry.
Just visit talkpython.fm/sentry and get started for free.
And be sure to use the promo code talkpython, all one word.
Want to level up your Python?
We have one of the largest catalogs of Python video courses over at Talk Python.
Our content ranges from true beginners to deeply advanced topics like memory and async.
And best of all, there's not a subscription in sight.
Check it out for yourself at training.talkpython.fm.
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.
We should be right at the top.
You can also find the iTunes feed at /iTunes, the Google Play feed at /play, and the Direct RSS feed at /rss on talkpython.fm.
We're live streaming most of our recordings these days.
If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube.
This is your host, Michael Kennedy.
Thanks so much for listening.
I really appreciate it. Now get out there and write some Python code.
[MUSIC]
