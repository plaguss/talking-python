When you think about embedded programming, does it bring low level languages and tools to mind, maybe embedded C or even Assembly Language? Thanks to the groundbreaking work by Damien George back in 2014. To create Micro Python, Python is one of the very solid choices for building tiny programmable devices. On this episode, we welcome back Damian George from micro Python, along with Scott shockcraft. From circuit Python and Adafruit will talk about how these two frameworks are solving similar problems with slightly different philosophies. More importantly, they are working closely to bring micro Python and circuit Python more in sync. This is Talk Python to Me Episode 325, recorded July 8 2021.
I'm the creator of Micro Python. It's been a long journey in the past nine years, nine years or so. Before that I was theoretical physicist. And I studied at Melbourne University in Australia and did a PhD in Theoretical physics. My PhD was in extra dimensions and kind of string
theory related stuff. And that's super cool. Yeah, it was it's no secret. It couldn't be like, you know, astrophysics type thing. It's got to be something small if you're working on micro Python, right, like,
Well, the thing with the particle physics is all about the tiny, tiny things. The Yeah, Quarks is sort of as small as we know, but also linking to cosmology, which is the really, really huge thing, and the idea of cosmology is to link the tiny with the large. But yeah, that's all I guess, very different from microcontrollers in programming, and software and hardware and real tangible things. How did you get from physics,
to the programming side of things,
I always liked computers and programming. And I always sort of had that as a side hobby. And I actually also studied computer engineering, and mathematics. And physics was the thing I kept, you know, I did sort of professionally, if you could say that, and always had on the side, you know, microcontrollers, and my desk and CNC machines, and then sort of half built robots. Fantastic. Yeah. So turn that eventually into micro Python. And when I was doing the PhD, when I was doing a postdoc in Cambridge, and did a 'KickStarter' with micro Python, and that all sort of continued on and continued and grew and grew. And that's how I sort of end up where I am now.
Oh, Kickstarter was so neat when it came out in 2015 2014. Whatever time that was, it seemed like at such possibility now, I don't hear about it as much anymore. I know it's still out there. But I think it was a bit earlier than that, because
we did it. Yeah. Enter 2013. And it's already been around a few years. Yeah. Yeah. But it was Yeah, such a huge thing. back then.
Super, super cool that you lasted it on that. Scott, how about you.
So I got into programming with PHP was my first language I came kind of like from the web side of things. And then when I wanted to do desktop apps, I found Python, and you can still find a source for page SourceForge page for a program called 'Denu', which is like dynamic menu stuff or like managing your menus and Linux. That was my first Python program that was 2004. So that's before I went to university and then I got a computer engineering degree. And I taught some of the intro ta classes there and did like a Python version of it there. So like pythons kind of always followed me. Throughout my career after university, I did six years in industry, and then took a year off and did drone flight controller hardware stuff. And then when that was like, coming to an end, when I was gonna have to find a new job, I went to Adafruit, and said, like, hey, I need a job. And there, they were, like, Hey, we have this project in mind UK doing a project that we want and it was to do bring micro Python to their boards that had a different microcontroller than what micro Python supported originally. So that was in August to 2016 that I started working on the Adafruit version of micro Python with Then became circuit Python. So circuit Python is a fork of micro Python that originally was for Adafruit microcontrollers, and we've really pushed it to be really uniform and a good beginner experience. So that's kind of how we fit in. Yeah, super brief. Well,
it sounds to me like with your drone experience, and all the small servos and electronics, and then this programming background, it's kind of a nice thing to bring together as well. Right? Yeah. I
mean, I, I had done Python for a long, long time. And I had just gotten into embedded and what I really liked that that the software depth, so to speak, is like much thinner, right? Like, there's a lot less software between the hardware and your code. And I thought that was really cool. And micro Python was an amazing how well it brought brings Python to, to those inexpensive devices.
Yeah, so Micro Python was first, Damian, and then circuit Python was forked from it to, like Scott said, to make it work a little bit closer with the Adafruit stuff. It's that sort of the history of it there.
Yeah, there's sort of a different focus on the use, the sort of the end user, and what level of experience you have, and kind of what you intend to do with the device. So I see it as Micro Python being used in industry and professionally, to build products. And circuit Python is to support well, initially to support Adafruit hardware, but also more for kind of beginners and people who are getting into hardware and want to have a sort of much easier onboarding with libraries and things that that are working with the hardware that Adafruit provides. So there's a real distinction there with the audience, and therefore the kind of features and things that we focus on. So there's a lot of focus in Micro Python, on code coverage and making sure things are really stable or stable as if we could make them across releases so that people who are working with Micro Python in a product can continue to work. And it's and be confident that updating will will fix bugs and not change other things to drastically and we get Yeah, we get a lot of sort of requests for features and bug fixes and things from people using it professionally. And so I have to keep an eye out sort of on a lot of all these things. So that when they come together, all the people I know who are using Micro Python, and not not going to suddenly be the head of the rug pulled out from under that when they switch to the next version, because something else has changed.
Right. That's an interesting distinction. The Pro production side versus Adafruit is so very welcoming towards. This is your first project, your first IoT thing, I like to build something for like a science project. I mean, Scott, maybe you could classify better, you know, certainly better than I do with the the specific focuses. But when I go to Adafruit and I look around, I get this feel that it's very much like these kits and very supportive of a getting started and not like hey, how's your robot doing? Here's where you plug in the thing for your industrial car making robot?
I think you're both right. on it, I think there's there's a bit, two aspects to it. One is like the focus that I brought to the project, and I mentioned the TA in the intro course, in university, because I think that does have a lot of influence over how I drive or focus for Circuit Python is like, we're very focused on what that experience and the first five minutes that you've ever programmed, not just hardware, but programming in general, what that first five minute experience is. So we've done things like all of those circuit Python boards that we now support are all show up as a USB drive once you've put Circuit Python on it. And so all of the tutorials and things that we written on top of that is uniform across that and then that dovetails nicely into into a diverse business model, where they really do focus on beginners, because the reality is, is there's far more beginners than there are intermediate and advanced electronics, folks. So from a business perspective, Adafruit interested in the beginner side, just because that's where the vast majority of people are.
Yeah, I also feel like the Zen or the ethos of Adafruit at the beginning was to inspire people getting into programming and getting into hardware, like from the beginning, right, that was sort of almost why it was founded.
Yeah, I mean, like Adafruit started around like, it's always been a matter of open source software, open source hardware, and open source tutorials, right like Limor, the founder of Adafruit, who goes by Lady ADA, like she started even before Adafruit was a company writing tutorials about how people could go get all the parts to build this one thing. So that's very, you know, a lot of what we think about what circuit Python is not necessarily teaching code from if statements and for loops, but actually just getting you all the code to do a project and then from there, now it's modifying that project in the way that you want rather than starting from a blank screen.
Yeah, very cool. coming out in the live stream, Sean Tibor from teaching Python Podcast Sean. He's a teacher who teaches programming also. I know uses just some of the Adafruit stuff in circuit Python says the speed from zero to blinky lights is really important for learning. We've got that study from the BBC Micro bit where they gave that to, I guess all seventh graders or something in the UK thing that's roughly right anyway, and it really changed how many people saw themselves as interested in programming, especially young girls said well they're way more likely to take a programming course, after having something physical and neat that you can play with, rather than just a terminal with a print statement. I think that I agree with that as well. What do you think I agree,
getting a blinking light it's the Hello World of microcontrollers. But it's actually it's actually really quite hard. You know, whatever your piece of hardware is. So often, when I'm making, Micro Python work on a new piece of hardware, thing you can get to once you can get a blinking LED, then you're sort of set. But getting there is really hard. And I'm not talking actually about blinking an LED in Python, I'm just you know clicking LED however you can in Assembly or C or whatever. Because you know, getting a toolchain working, making this, you know, plugging in the board powering up knowing how to power it up, knowing how to get it into a mode where you can change the firmware on it. These things take, you know, can take days. I mean, yeah, on the longer end, and why serial port working,
right. And yeah, all sorts of stuff. Yeah.
So to support Micro Python to a new microcontroller, once you've got a tool chain, a way to flash the device, and you can blink an LED or write characters to where you are, then getting microphone working is probably another hours worth of work, it's and then and then you've got, you know, the whole of micro Python ecosystem that you can play with. But from an beginners point of view, it's a similar sort of story when they want to, like get something they've never done it before they've got a piece of hardware, and you know what's going on. So blinking LED to get to that stage, there's a lot of conceptual hurdles. And also, you know, maybe installing things on your computer hurdles as well. But to get to a blinking IDs is really the beginning. And then from there, you can be a whole sort of World of possibility opens up because you can see then how you can turn that into a real life project.
Yeah start to work with the other sensors. Yeah, things like the accelerometers or motion or microphone or anything, right? Exactly. Yep. Yeah, I think maybe it makes sense to pause for just a moment and define microcontroller for people. So I have a Mac Mini here, it's small, right? That's not a microcontroller, I could get a Raspberry Pi, which is even smaller, still not a microcontroller, like give us a sense for the size of these boards. And like, what is the hardware look like?
It's not really physical size. A microcontroller itself is actually more complicated than a PC in some sense that a PC like a Mac Mini or a laptop, or Raspberry Pi, that has a CPU in it. And it's connected, usually to a keyboard and a screen and maybe some audio, and Wi Fi. It's a kind of internet. And it's relatively straightforward. It's a CPU that is fast and does a lot of processing and can output to a screen that a high refresh rate and you can interact with it. But a microcontroller is a CPU plus a lot of other peripherals around it. Like you had an SPI and ITC and I2s and Ethernet and Wi Fi and then really low level stuff like DMA, and things that make the microcontroller work in a microcontroller away, timers that interrupted very precisely. So a microcontroller is what they say sometimes a system on a chip Soc. It's a real, tightly interconnected piece of silicon, which has a CPU at the center, which controls things. But what's more important, it's the things it's controlling. And it's got to do that in a really precise and real time. way. So that what it's controlling, say, the coffee machine, or an aeroplane, is guaranteed to work every time the same way and run for years without having any problems. But if you have a laptop, and you know, it's probably not going to run for years, without needing to be upgraded, or you know, crashing for some reason, oh, you know, it's odd how that works, right? There is this kind of distinction there. It's a bit subtle, but the microcontroller is, is a really precise machine and a really complex machine in the way it interacts.
Would you say more real time?
Yes, that's one of its tasks is to be real time. And it's not as powerful as a laptop or a PC, but it is more sort of capable. And also programming it is a lot harder.
So I think it's important to say that like microcontrollers are typically used to do a single task in a larger system. So think of your car and like I think a Tesla has like a microcontroller that manages the door handle, for example. So microcontrollers are in a lot of things Damien said toasters another example. So that means that they're, they're everywhere, you just don't see them. And that has the benefit of being very low cost. So the the microcontrollers, which are like the black chip on the circuit playground you see here, they're only like a couple centimeters square, you know, they'll cost under $1, or a few dollars at most, which means that they're really inexpensive to get into. And in terms of processing power, what you'll see is like, if my desktop has 32 gigs of RAM, right, but a microcontroller will have anywhere from like eight kilobytes of RAM up to maybe a megabyte of RAM, or a few megabytes of RAM at the at the higher end, the distinction between like a microcontroller and a microprocessor also involves like how good it is it doing multiple things, specifically, like there's memory protection, stuff that will happen in your like desktop CPU that a microcontroller typically cannot do. So really, it's usually just a single task thing.
Unlike Mac OS, or Linux or whatever, you've got the OS. And then it's running your processes. Often in user space, they have protected memory, there's a bunch of them, the OS is doing pre emptive, multi threading, all those kinds of things. This you, your Python program, your micro Python, or circuit Python, basically, is the operating system almost right? It's like full control, right? This portion of 'Talk Python to Me' is brought to you by SENTRY. How would you like to remove a little stress from your life? Do you worry that users might be having difficulties or are encountering errors in your app right now? Do you even know it until they send that support email? How much better would it be have the error and performance details immediately sent to you, including the call stack and values of local variables and the active user recorded in that report? With Sentry. This is not only possible, it's simple. In fact, we use Sentry on all the talk Python and web properties, we've actually fixed a bug triggered by a user and had the upgrade ready to roll out as we got their support email, that was a great email to write back, we saw your error and have already rolled out the fix. Imagine their surprise, surprise and delight your users today, create your Sentry account at 'talkpython.fm/sentry. And if you sign up with a code 'talkpython2021'. It's good for two months of Sentries team plan, which will give you up to 20 times as many monthly events as well as other features. So just use that code talkpython2021 as your promo code when you sign up.
In some cases, there's a real time operating system under the hood. But in some other cases there there isn't. Okay,
interesting. So one of the things that might be fun to talk about is we've got Micro Python, and we've got Circuit Python. And we've also, you know, people say Python, they often mean python.org, C, Python, Python, Damien, you want to start us off with maybe like, what's the difference between this huge I don't know how large it is 40 50 megabyte thing I download from python.org? And then maybe what Micro Python is, what's the same? And what's different? Can I write? Can I take a random Python program and run it on Micro Python? So
on? It's sort of the biggest thing about what if it's called Python, like micro Python? You know, shouldn't it be just the same as Python? And why can't I just use Python instead, if it's the same? Yeah. So to begin with, you can't run Python on a little microcontroller. Because it Python it, it uses too much memory is kind of the base. Really,
the reason just to load the runtime libraries probably exceeds the entire working memory, some of these chips, right,
just to load sort of the mapping table of Unicode character names is megabytes of data, which micro Python obviously doesn't support. But so the one of the main things, when I was writing micro Python, was to make sure it didn't use memory where possible. So all of the things that could be put into read only memory, or flash or ROM were put in there. So dictionaries and modules, and things that are sort of built in, like a sys module, all of that is in Read Only Memory in micro Python, and circuit Python, whereas in normal Python, pretty much everything is, is put into Ram. And so when you make, if you tried to run Python on C, Python on a microcontroller, you would need megabytes of RAM. And that really is the main difference. But then there's a lot of other you know, things on sort of a list of things that are different to make micro Python efficient on a microcontroller to make it small and code size to make it run relatively efficiently. And as part of that, we had to make some sacrifices in compatibility with C Python. So there are some things that are not the same. But for the most part it micro Python and circuit Python really do feel like normal Python, the syntax is the same, at least up to a given Python version. Because Python keeps adding syntax. The syntax is exactly the same and the semantics of the syntax are the same and a One of the built in types, you know, well, one to one mapping with the same semantics and the same methods. So there's a lot of things down there that are very similar, very, very similar, because Python is such a dynamic language in such a big language that it has so many sort of little corner cases and things that are, you know, behave a certain way and when you're used to Python are used to the I want to change the
metaclass. So that this other thing does this other weird thing in this way? And I'm expecting to patch that when we load this module and yeah, yeah, exactly. skotching his head, like maybe not.
But even down to things like how division of modular work with negative numbers is sort of very specific, you know, when you have A modular B and the negative numbers, then the answer is a certain way. And micro Python copies that as well. So there's a lot of subtleties there that you may not realize that over the years, we've gotten to make sure it's right same  with C Python, just because we've got a lot of tests and a lot of people giving feedback when it's not exactly as they expect. Yeah. And yeah, I mean, I definitely learned so much about C Python. And well, the Python language, because so many things, I had no idea about, like, well,
you had to get the exact nuanced details of how this thing or that thing works right here, make sure it's the same. One of the things that I think is worth keeping in mind is people think about this as when somebody says, I love Python, or I think Python works this way, or Python is this thing, and it's productive, or it's whatever, it's slow, it's fast. They often can be talking about many things. Somebody could say, I love Python, and they mean the Python syntax. Somebody could say, I love Python, the reg of the standard library is so cool that it comes with all these things in the standard library. They could mean I PIP installed Pandas and request and now something cool happened. Yeah, right. When when you say Python runs there, there's like, you kind of gotta say, Okay, well, what are we talking about? Right? Are we it? Mostly the language for sure. But um, there's got to be a ton of standard library things that don't make sense. Like there's this one about parsing CSS, hex values, like who cares? TK enter? Don't care. Yeah, SQL Lite. Maybe? I don't know.
Yeah, I was gonna say I did actually do like lightning talk at the last language summit kind of on this topic. And like Damien's saying, like, to his credit, Micro Python, is Python in the core syntax areas in the built in types. But as you kind of grow outwards into like, the standard library, things get omitted a lot. Because the frankly, the standard library in CPython is large. Yeah. And so I did kind of a comparison there. And I can share people with the slides. But like, take all this stuff in C Python and show what's in in Circuit Python. That's cool. I've been having like discussions off and on with Brett Canada about this as well, because he's been thinking about, like, how would you define like a minimum version of Python. And I think that Micro Python did such a great job of that. It feels like Python to me. I had the background in Python before. So like coming to Micro Python, it felt very natural. So I think we're a good case for that.
Yeah, I think you definitely are, you know, Brett was, I know, he's been thinking a lot about Webassembly. And what would it look like if we could have Python and webassembly? And we could have these other, you know, like, what would a mobile Python look like? And these different environments that are not just desktops plus servers, and having this standard core Python subset is a pretty neat idea. Yeah. A couple of things from the livestream. Sean has a warning for everyone who gets into this, that these microcontrollers tend to multiply quickly. He started with just one or two now as a whole collection. I can't see what's in your background, Damian. But Scott, you seem to have a bunch of these things gathered around.
Oh, yeah, this room is a mess right now. I probably have at least a dozen on my desk, though, as well. And yeah,
there's, I just got to find new and inventive ways of actually organizing them. Because, I mean, the thing like, you know, a box full of dev boards, sort of in plastic blister packs,
I take them out of the the blister packs are too big. Let's try to take those out. Yeah. Oh, my God, just per manufacturer. So like STM NRF. At Mel of all the different development boards. Yeah, yeah, that's just yeah, there's a whole lot of stuff everywhere. Like, just just they're inexpensive. They're impulse buyable, which is bad. Exactly. I'll
take three of those. And one of these and yeah, amazing. But it's got to be a collection of cool little things.
Yeah, it's also important to figure out like, what each individual microcontroller can do uniquely, uniquely, what makes something unique. Like it's obvious, like, if it's a ble chip, then that's obviously what you want to do. If it's Wi Fi, that's what it can do. But the RP 2040, which is the new chip from Raspberry Pi, like they have this really weird, unique peripheral that allows to do really, really, really real time stuff, because an actual CPU and a microcontroller is still not perfectly real time. So they had this like, special thing that they added that can do some really impressive real time stuff. It's very interesting to see like, the stuff that's standard between all these things, and then what's different.
Yeah, I can imagine one more interesting thing to ask you about from the livestream. Tim out there as you know, what are your thoughts on circuit Python being used in TI calculators? So the the new TI 84 comes with programming as you can write Python in here. I don't remember what the Oh, here it is the programming bits we can see. But yeah, I mean, I remember programming in calculators being like, really, really weird. Yeah, I did that. Actually. Yeah, this year, I mean, a little bit funky. But you know, heavy Python. There's it's quite nice as well. Yeah. So this is
a fork of Circuit Python. Interesting. It's not publicly released, which is totally okay. They are careful not to call it Circuit Python, which is good as well. But that does mean that like, if you go to 'circuit python.org,/downloads', you won't find like the latest version of Circuit Python for your calculator. But generally, I think it's great. Like, I love seeing people build on circuit Python, just like we've built on on micro Python. Like,
yeah, people should do that. It's really neat. Yeah, absolutely. And then another one out there. That's neat that says, Matt says, Micro Python and the new Lego spike delighted the inner teenager me. Did you did you catch that? He must have known about this, right?
Yes. How did you take this news? Yeah, that was pretty amazing. If it was a year or a couple years ago, I think was maybe the longer three years. Yeah. When they started while they contacted me about it. So it's still an ongoing thing you can. There's a Lego education, which is separate to sort of Lego retail. Lego education is for schools. I remember using that when I was in high school a long time ago. It's obviously Lego. But it's the different kit, and it's different focus on what you do with it. And the Lego education these days, sort of the new version of Mindstorms system uses Micro Python, in the hub of the sort of the central processing unit of the Central's Lego control box. Do
they expose that to the kids to play with? Or is it just like a runtime internal sort of thing?
It's kind of both the thing that you can get from negotiation is using Micro Python to implement sort of the what the kids see. But I think there are plans to make it so that you can actually use Micro Python directly.
That'd be that'd be really neat. Yeah, very cool. I think it's, it's great. Scott is about the comparison between Micro Python and C Python, you want to close the circle and go from maybe the differences of Micro Python and Circuit Python, like Why are there two things here and whatnot? Why how people think about like, if I'm going to work with one or the other, where would they go?
Yeah, so I think the Why is what Damon iterated earlier is like our focus in Circuit Python really is beginners. And coming into Adafruit. I also knew that the their model is that like for every device that they sell, they provide example code and drivers for it. And because Adafruit was going to do this for the Python world, we had to make sure that the hardware abstraction layer, like the the modules, you import in Python, that allow you access to the hardware, we'd be consistent across everything that runs Circuit Python, so you saw me get like a little niggly about like, it's not actually Circuit Python on the TI calculator, because like, I think the branding of Circuit Python is really important, because it means that you can download it from the website, you can use the API's that we have standard as Circuit Python, and therefore all of our circuit Python libraries work on top of that all our guides for Circuit Python work on top of that, yeah, so that was really, you know, one of the more important things for us is having that uniform API that we can then build all of this Python software on top of, that's one of the main main differences, it should be, I should say that we do actually have this layer called 'Blinka now, that allows you to use micro Python under the hood or actually C Python under the hood. But it presents that same circuit Python API for other things as well, this line has been blurred some, the thing that doesn't come with that is that we in Circuit Python, we still do ensure that you're kind of workflow is the same as well. So all of the circuit Python boards that you can download now, except in the future, this is going to change the show up as a as a circuit py drive, and you can edit the code.py file on it, it runs after you save it automatically. And it's really quick and easy to iterate on. Right. So basically, there's a file watcher that looks at your, your source file, that is the program, if it sees it changes, it kind of just reboots super quick and reruns it right. It's not even that smart. It's any right to the file system. It doesn't know what it doesn't know what file you're writing to. It's just any right will trigger that. And the caveat I had is I'm working on a ble only workflow as well. So in the future, there will be two ways of using circuit Python there will be a USB way and a Bluetooth Low Energy way I see. So you don't have to actually connect physically to the thing. It could be over there. You could program it that ends from phones, phones and tablets in particular, devices that are really easily interoperable over USB. We want to bring the beginner experience of programming in circuit Python to those devices as well. Yeah, so that's the caveat. Like right now everything does USB, but I'm like working on the micro bit v2 right now that will not be doing USB. It'll only be doing Bluetooth Low Energy.
That's sounds It's more complicated. Yeah, it is, but also very useful. But I just without a wire, you know? Yeah, I'm just thinking of when my headphones I get disconnected I call interference. How frustrating and but you know when that's your connection, right?
Yeah, Bluetooth come a long way and I have had it working a bit a lot of the challenge with Bluetooth is there's no standard way of doing like file transfer. So we really like we're working on apps to be able to transfer files and apps that are letting you pull that will pull down all the example code and automatically load that over. And that file transfer API that we have is all public. So if folks want to link to that, I can send them a link to that protocol. So yeah, there's a lot more work off the device to do for this Bluetooth, Bluetooth stuff. That's cool.
So I see on circuitpython.org, it says blinka, and circuit Python libraries are just a pip install away. So if I'm working, but I'm on my desktop machine or server machine, can I still do like prototyping and try the library's What does that mean?
It's not every computer, if you're on a Raspberry Pi, it will work because that is supported. If you actually I think if you click that single board computers link, it will show you all the ones that we specifically support. But single board computer is like a Linux class computer that usually breaks out general purpose IO GPIO. So that's kind of the class of Linux computers that you'll be able to use this on. Okay. And then we do also have a couple cases where you could like plug something into your USB that would also like give you that GPIO on another device.
This portion of Talk Python to Me is sponsored by Linode. Visit 'talkpython.fm/linode'. To see why Linode has been voted the top infrastructure as a service provider by both G2 and 'TrustRadius'. From their award winning support, which is offered 24/7, 365 to every level of user, the ease of use and setup. It's clear why developers have been trusting Linode for projects both big and small, since 2003. deploy your entire application stack with Linode to one click app marketplace, or build it all from scratch and manage everything yourself with supported centralized tools like Terraform. The Linode offers the best price of performance value for all compute instances, including GPUs, as well as block storage Kubernetes. And their upcoming 'Bare Metal' release. Linode makes cloud computing fast, simple and affordable, allowing you to focus on your projects, not your infrastructure. Visit 'talkpython.fm/linode'. and sign up with your Google account, your GitHub account or your email address. And you'll get $100 in credit, as 'talk python.fm/linode'. Or just click the link in your podcast player show notes. And thank them for supporting Talk Python. Question from the live stream for Tim against How has the workflow changed over the past few years for circuit Python and micro Python when deploying code? And it sounds like Matz talking about MP remote? Do you want to talk about what the deployment looks like?
Um, yeah, there's I guess, yeah, there's a lot of sort of answer to that question. From micro Python point of view. As I mentioned, if, if you're using micro Python, in a product, then it's a really different set up as if you're using, you know, hobby trying to make it light turn on and off. So using it in a professional setting, you'll probably have a big sort of workflow or set up where you can freeze the code into micro Python and deploy it or, or something like a
production. What do you put actually on there? Do you put would you go and say, well, we're gonna put a pyc. file there instead of the Python file? Yeah. Is there stuff like that? You might do? Yeah, it's not
it, we have mpy  sort of, instead of PYC, pre compiled code, yes. But there's sort of another further step where you can take pre compiled code, and then sort of freeze that into a C data structure, which becomes part of the firmware itself. So big projects, will might have hundreds of Python files, which are then all pre compiled and frozen, and then built into the firmware and then deploy it onto the device.
Is there any room for something like cython, or Numba or some one of these C compiler type things?
Yeah, so they don't really support that. But you can write C code as well, if you need to, if you really need speed, you can implement a module and C and then tie that into Python quite easily. So there are lots of options in terms of making things fast or efficient or related to your workflow. But sort of to get back to the original question.  MP remote is a new tool that was released in the last version, and it's intended to make a workflow. Well give me more options. You can use it to copy files on and off, get a repple on the board, or one of the main features is to mount so make your PC's file system available on the device that you're running on. So you mount your PC's filesystem on your pie board or ESP 32 or whatever. And then when you go on to the board and do it I was
Yeah, it's neat. When I want to put something onto my server to, you know, to upgrade like, or site, something like that. I'll do some work locally, I'll do a git push, magical happen. GitHub will do a web hook back over to the server, the server will grab that, it'll pull it down, install the new dependencies, restart the server through like a zero downtime, sort of firewall type of thing. If I have a robot in a factory, what do I do here? Is there a continuous deployment equivalent for micro Python things? Or what's the story look like over there?
That's a good question. We don't we don't I think this came up the last time we had a couple chats between like the folks that work on circuit Python and the folks that work on micro Python. I think this was kind of a topic that we all said like, Yeah, that'd be really nice.
We don't have a sort of recommended or official way to do all of that. But what I guess what you're talking about over the air updates, maybe kind of answers your question,
basically. Yeah, like if I had a Tesla, it, sometimes I wake up in the morning, maybe my Tesla does different things. It's something like that. Micro Python things. Well,
if you have a factory full of robots, you probably don't want them to automatically update because you, you need to be there when it happens. And you need to control it and do it at the right time, and so on. Yeah, it really depends heavily on the project that you have. But over the outdates, sort of Definitely, yeah, the way to do this, and they have been done. And they are sort of out in the field. And they're done in lots of different ways, like some over Bluetooth, where you download the new firmware, and then
do a little like what Scott's working on now? Yeah, yeah,
sort of an automatic way to install the new code and then reboot. And in other places where it's, they're connected via USB, and you can just do a normal DFU upgrade, or similar or maybe over ITC, they're listening in a special mode to download new code there are, there are lots of ways to do it. And there are lots of sort of parts in micro Python code that allow you to do it. And it really depends on your project. I think that probably Scott has a different answer.
I was gonna say from the hobby side, like it's never, I don't we don't focus on the automated update story. But you know, a lot of the folks that use circuit Python are coming from an Arduino world. So Arduino is really common hobby. It's based on C, but it's got some like, stuff on top of the C stuff. But it means that you have to like have a computer that has Arduino installed that can compile the source code. And because we focus so much on this interaction of like it shows up as a USB drive, it actually means that anybody, it makes it more accessible to update. So if if I'm remote, and somebody wrote the software for me once, but now they want me to update it, like even though I don't understand how it's doing, I can plug it in, it shows up as a drive, and I can copy files over. So it's really has been beneficial for folks that way, whether it's the Python code, they're updating, or a lot of our boards also come with a bootloader, which is like the software that manages what you're installing. And a lot of our boot loaders for devices also show up as a drive as well. So it's still a manual process, but it's a manual process that's gotten better from from the previous things,
right. And from a hobby perspective, you can have a little app or something that says, Oh, I noticed we're connected to this thing. And we're just gonna, it's out of date, or it's gonna push some stuff to it.
Yeah, we actually have some community members who've really fleshed out this app called CIRCUP, c-i-r-c-u-p, which you can pip install, and that will like figure out all the libraries on your circuit py drive that are out of date and update them for you. Okay, which is pretty neat. Yeah, it's kind of like the PIP of circuit of circuit Python. Yeah, I'm
just sure the requirements and concerns are extremely different if you're working with, you know, a small hobby device versus something that is controlling a robot or runs a thing that shouldn't go down. So one thing yeah, I wanted to definitely focus on while we were here together, seeing I find it is somewhere. oh it's hiding now. There's a lot of work that has been done. It sounds to me like on the circuit Python side to catch up with micro Python. Is that right? Or tell us about that, Scott?
Yeah, so the history of this is like when Adafruit started paying me to work on what became circuit Python, it was like, Okay, I'm going to write a whole lot of code, right? So that's when on GitHub, I hit fork. That's what I added a new port for Atmel Sam D. And that's kind of when we split and later on we decided like oh, you know, like we have enough changes here that it would be a lot of work for both Damien and us to get those changes merged back together. And that's still very true. But what I said at the time was that we would kind of keep pace for every stable release that we do, we would keep pace with stable releases for micro Python. That wasn't true for about like two or three years, we stopped updating, we do it's basically a git merge, right? So it's, it's Yeah, it's a whole lot of work. And so I did, we had six versions of micro Python, the merging, so I did those, that's like one, let 112 through 115, or 110, something like that. And then since then, we've actually updated 116, as well. So what's involved with that is like micro Python has both like a Py folder, which you can think of is kind of like the VM, we think of that as kind of a core. And then there's separate ports for each main type of chip that we support. And we don't really share code with micro Python for those different implementations for different chips. But we do share that core Python VM. So a lot of the work to emerge in micro Python is like updating all of that core stuff. And the discussions that Damien I and I have had, along with the other folks that work on these two projects has been like, Alright, like, what can we do just to get back to this world where we have the same copy of that PY folder? Yeah, because there's like a few, a few weird things that like circuit Python has done that haven't been merged back into micro Python. And we've had discussions about which things are those are interesting, and which ones we want to make configurable and things like that? Yeah. Interesting. Now that we're updated, we have this foundation where we can have this discussion again, because we actually can tell like, what the differences are between the two latest versions of these projects. Yeah,
yeah. Larry Bank out the live stream says my imaging codecs have been merged into micro Python. There's a lot of things that haven't been merged into micro pricing. Yeah, David, I was gonna ask you, you know, what does this mean for micro Python, like, obviously, it makes sense for circuit Python to just not be out of date. And, you know, the farther you are away from one of these merchants, it's more like credit card debt and a little bit, it's fine. But as it gets farther, it starts to become a problem. But in reverse, there's probably a lot of things that people who are engaged on the circuit Python side could bring back if it was basically the same
Yeah there's some great things a circuit Python Scott has done with garbage collection for one thing, and it would be great to share a common py folder at leaf. And we'd have, as he said, we've had discussions about sort of how we can smooth things or make things more common. And where we know we differ, you know, how we can make it easier that we differ recently, actually a really good improvement in micro Python for tab completions I that I didn't have the underscore and also tab completed imports, your inputs based had a list of templates of things, you can import some good improvements for sort of fuzzing and sanitization dresses, sort of various subtle bug fixes that have come across. So it's Yeah, look, it's really great to have an open source project. And because other people find bugs and fix them, yeah, the more we can be in line, the better. And there are actually other I mean, there are other people using micro Python and circuit Python, as we saw with the calculator,
and Lego. Yeah,
yeah. And I think in the early days, I was happy people were using micro Python. And I wasn't too concerned about sort of people forking and changing things. But these days, my, I've shifted more towards, well, what can micro Python do to make it easier for other people to use it without changing it? Right? And so when they're about to think maybe I need to fork this to do this, you're like, Well, why are they about to push that button? What? Make it more extensible, or whatever it needs to be? Right? Yeah, how can we make someone else's life easier, so they don't have before? Not that we want to accommodate everybody? And we can't, but you know, it doesn't make sense to talk to these people, and then make sure that their needs can be met in a sensible way. And maybe it helps everyone else as well. So, yeah, it just it helps the community when you have less sort of forking and more cohesion.
Yeah, definitely. I mean, we've seen the Python two Python three stuff, mostly get resolved by people finally, moving on to the same place where the core devs spend their time. And I think that that's, it's only been beneficial. It seems like a lot of projects are taking some of these ideas and picking up speed, whereas there used to be a lot of hesitancy as there's like, many different paths in the road. And yeah,
well, I'm just glad I had you Python 3 from the beginning with with micropython.
was just playing around with this, I was able to use like a smiley face emoji is a variable name, and it just worked, which kind of blew my mind. So that's super credit to Damien for making micro Python really, really strong, really robust and really Python. Yeah, I think you know, in terms of like circuit, Python and micro Python, another thing that we can really compliment micro Python with is like we can I'm we're willing to be more experimental. Damien alluded to this memory allocation thing that you You, I pitched to him at one point and he was like, good. I was like, well, we'll put it in circuit by then we'll see how it goes. And then you can decide whether you want it or not. So I think that's a benefit that we can have in circuit Python is that like, because Damian really wants micro Python to be stable we can, we can try things out in circuit Python, and then he can pick the things that he wants to move into micro Python. That's a fantastic way to look at it. And the fact that you've got these merge differences or these version differences down to such a small gap that like, well, that would have worked three years ago, I'm not sure it works. Now. Right? Now, you're basically experimenting on what is the real thing? Yeah, that's helpful for like this tab complete thing where like, somebody added it in the circuit, Python, and we merged it. But then they also made a pull request to micro Python, and like, making sure that they're starting from a closer baseline will will help everybody as well.
Yeah. Yeah.
I mean, it's, really good to hear you do 116. And we're trying hard for micro Python side to release every two months or so. so that it's easier for everybody to upgrade. And then it doesn't take so long for a new release to come out.
Yeah. And what's the schedule for circuit Python? Scott,
we don't have a set timeline, we do try to get in a rhythm of do we do both stable and pre release releases. And we don't have kind of a fixed schedule. But we we tend to try to have like pretty recent pre releases out, if it's been long enough that we're recommending the pre release or the stable release, we ask ourselves like, Okay, why aren't we just calling this a stable release? Right, that kind of that gives us a forcing function to up the stable release, we are kind of in this window between major releases. So we're currently like doing 7.0 stable, or pre releases for that that's a chance when we did all these merges, because we get a lot of instability, not because the code we're merging in is bad. But the merge is really hard. And it's hard to get correct. So we're kind of in this sort of, like, very big state of flux right now with circuit Python, where a lot of things are changing. And we're very quickly approaching this like, Alright, we got to stop changing things so that we can stabilize because we're no longer recommending the stable release. We're recommending the pre release. Yeah. Because like when you somebody introduces a new board, and it's like, oh, well, that new board is not supported in the stable release, you have to use the pre release, like, that's a largely a forcing function for us
interesting that the hardware is driving the software like that.
Yeah. And that's a thing from like, a number of us are funded by Adafruit to work on it. So when Adafruit releases new hardware, we have to decide like how we're going to make it available.
Absolutely. All right, let me take one question from the live stream. This is from Murray. Hey, Marie. I don't actually know the details. I'll read to you. I'm sure you all do. Here's a different question. What's the state of micropython.lib project? As regards to the bigger micro Python project?
That's a good question. The aim is to switch to, you know, improving micro Python labor, it languished a bit because well, there was just a lot of stuff to do in the main repository. But now that a lot of the code in the main repository has sort of stabilized and settled down and mature, there's more scope. Now to go and write everything, well run all the extra bits in Python and put them in micropython.lib. So we have recently reorganized that repository to be a bit clearer as to what's in there. And the aim is to maintain it and keep it running and put lots of libraries in there, improve the C Python standard library support. And other things there, you might have noticed there was AIOBLE, which is a, asynchronous Bluetooth library, which is in micro Python lib, and is being used in production, it's pretty good in terms of stability. It's very good in terms of features and what it can do. It's really quite amazing how it makes Bluetooth simple. Bluetooth is a very asynchronous thing, and a very high latency thing. So having an asynchronous API is really beneficial. So that's just one example of a library that is written in Python, pure Python. And is it micro Python lib. And we aim to continue that trend. I know that it's a little bit stale, some coding there, but we get  Fix fix things in the very near future.
Yeah. A very neat. Speaking of asynchronous, what are some of the question both of you, what are some of the shiny language features that are new and neat in there like async and await? Can I do that with a Bluetooth library? Or walrus? Can I do a walrus operator? What's going on?
Like, what can I do we have micro async i o UI async. io, which has, is in its third sort of iteration third version. And that's been I think, about a year old. Now, that version, and that also has been used in quite a few production systems. That's also quite stable, and I think, is a really good short case of using Python on microcontrollers, because things on microcontrollers. Well, some things take time, like reading a sensor and waiting for a Bluetooth packet to arrive. And you've got to do lots of things at once, like blink a light to integrate progress,
it'd be great to be able to take them as those events command, right?
Yeah. So event based, but also easy to sort of use because I mean, multi threading, using, you know, threading in Python, I can do, you can do that on some micro Python port. But it's heavy weight in the sense that it uses a lot of memory for each stack of stack of each thread. And it's slow to switch and respond. And so it's, it's, it's not a great solution. So cooperative multitasking, which is what async IO is, is, I think, a better solution than threading on a microcontroller. And even on desktop. Yeah. And it works really well, when you have something that's well suited to async. io, it's really, it's a really fun experience to program something that way.
It's aptly named, because what it's really well suited to is waiting on things like IO, right? We need on these devices, these various sensors and stuff to come back and just say, hey, I've got an input, I've got a callback or whatever, right? Like, that's, like the perfect case. It's not like, well, we're trying to do all this computational stuff asynchronously. Well, that work is quite well, that way. Yeah. Like, you know, you may just want
to wait for a pin to change from high to low. So you spawn a task, and you do you know, await on the pin. And then when that when that statement continues, that means the pin has changed. That's hard to do in a sort of callback based system. Ultimately, it's just a different conceptually. And maybe it's harder to reason about thing. So there are Yeah, we have support for these fancy features. async IO and the walrus operator we had in F strings. And not yet you know, I think circuit Python has as
you guys already have the F strings.
Damian has a higher bar for merging than we do addressing. So in circuit Python side, we have F strings merging, but we haven't done this work on the async stuff that Damien surely done. Because our audiences beginners, I really push just not to do async stuff. Because I think something that beginners don't necessarily understand is like, the computer literally does things in order that you want it to do. So a lot of the examples that I that would that we use, and that we get people to doing is just doesn't use async. So it's not been a focus of ours, one of the reasons to merge was to get the newer async stuff in and kind of hope that somebody would come along and turn it on and make sure it's all working. But kind of we've had the opposite, opposite approach. And and I think, talking about async, one of the things that we've been thinking about is like async is very networking oriented in terms of Python. And it's not necessarily clear how that impacts hardware API's and like waiting for pins and things. So I think it's really interesting to think about how async await applies to things like spy transactions, and I squared c transactions and in what exactly like, like, we talked about how circuit Python has a different hardware layer than micro Python does. And like, I don't think either of us have really come up with like, what does that look like when you have async await support? So I'm curious to see what what Damien comes here.
I mean, we do. We have recently merged i2s support, which has preliminary async IO support in it as well. So you can Yeah, asynchronously send and receive audio buffers, we also have async support for pins using Well, a small sort of piece of wrapper code. A thread safe flag is our main sort of interaction between interrupts and async. io. So you create a thread safe flag object on the async. io side, you could wait on the flag and on the IOq side, so some event happens, like a spy transaction completes, and you get an IR cue, and then you can set the thread safe flag, and then that will mean that the task waiting on that can continue. So yeah, but I agree, Scott, that it's still early days with API for connecting i2c and things like that into the async world. I know one project we're working on, uses async, io and Bluetooth and thread say flag with pins. But yeah, nothing else is async. But those things that I think I've been very important to be I think, and a lot of the time, just async IO .sleep is the thing you want, then you had just wait, wait for a bit of time. So you're waiting on a pin and sleeping is actually gets you a long way. So but I think it's still early days, and even async, I O and C Python is sort of still early days in the sense that they're still trying to work through what API is good for streams. And there's trio as well, which is providing good feedback to C Python async IO. So it's still early days in the whole sort of Python space.
Now. There's my favorite unsync, which is a unification layer on top of threads multiprocessing and async. I O. And it's like, I think the whole implementation is 126 lines of Python in one file, but it's it's glorious. Alright, one final topic I want to touch on. There's been a lot of interesting work about making Python, regular all server side desktop side c Python faster. There's been a bunch of interesting things coming on. Pigeon from Microsoft is kind They're making a comeback. I think you think Sean's doing some work on that maybe Brett cannon as well. There's Cinder, the Instagram crew has released with really interesting stuff going on about making a lot of interesting changes in the runtime about making it faster stuff about like immortal instances that that are sort of not subject to GC, and reference counting and whatnot, we've got the latest language summit, you know, was talking about interesting things he's doing and focusing on to try to sort of accomplish the same goal, like, Is any of this stuff influencing what you all are thinking about? Or is it just not really applicable? Yeah, this is a really big topic, because Python has a long history. And it's used in a lot of places for a lot of different things. And it's built by our community. Unlike other languages, I mean, lots of languages, like communities, but Python, in particular, is one of the most of the more popular languages that is really just community run and found the UI, we might say it as something like, it's built by a very diverse community, technically speaking, as opposed to say JavaScript, which is almost always web and then kind of recently, it's been a little node, but like, it's astrophysicists. It's embedded. It's data science, it's web. Like there's a lot of different pressures and areas that Python gets put in.
Yeah. And, and the focus has not been on performance. It's been on usability and features and keeping an
accountability. Yeah,
yeah. I mean, it's been it's such a, it is an old language that has evolved a long way, like C is an old language. But see hasn't changed that much to both classes. And all day? Well, c++ is changed a lot. But it's got a very big community around it, and lots of production. But Python is sort of, yeah, it's got such a sort of amazing and passionate community who do all this stuff for free. And performance is something that sort of always been in the back of people's minds, but it needs a lot of work. And it kind of needs a stable Python language. Before you can consider performance, you know, you can't optimize along the way of adding features, it's really hard. But anyway, this is sort of just to say that it's a big topic. And lots of people have tried to make Python faster. And PyPI is an amazing piece of software that makes Python faster. One of my first big Python projects, we use PyPI, because it was really, really good. And made things a lot faster, like 10 times faster. And we didn't have any sort of extension modules that didn't work PyPI, they will do work with pipe pipe. And it was it was really, really good. So use that if it works for you, we'll have it it's a bit bigger. But it's it, what it does, is does really well. On the other hand, making C Python faster, just the core c Python, I think is a fantastic goal. And I think probably the thing I would say is that any interest in Python is good for circuit Python and micro Python and the general Python ecosystem, just because it's people working on Python and trying to make it better. Whether or not, you know, there's something that comes out at the end is kind of secondary, it's that people are interested in hacking on things and having fun, things will come out of it, maybe it's not going to be very, super fast c Python at the end, although that would be really great. And that's what people are really, really working towards now. But I just think the general interest in Python is the biggest thing that will come to us is that, you know, Python will be in the headlines more, and people will be talking about how it's faster now. And it's interesting, and it will change people's perceptions. And then people will learn more about micro Python and through Python and C,
in the deal with all these articles that people are leaving, C and GO because it's so slow now.
Yeah, Python is Python, such an ergonomic language. It's so great.
It's so so lovely. I think actually, the performance side is just so too many layers, right? Like, it's slow, except for use the CyPy libraries all the sudden, it's really fast. And like, it's just, it's it's super interesting.
It really depends what you're using it for. And I don't think you should slow Python shouldn't be, it should be banished to that that concept. It should be like, use Python and see if it works for you. Because if it doesn't, you know, then use a different language. But that's the same you say with any language. It's like use the language if
it's gonna work for you. And oftentimes, it's just while you're not using the right part of the Python ecosystem to address that problem. Yeah, right. Yeah. Scott, do you want to maybe weigh in on that real quick before we wrap it up? That's about it.
I I generally, I delegate to Damien. Damien does a lot of work on this core and makes it really fast. I try not to get sucked into the performance stuff, because I'm trying to do the workflow side of things. But I did want to point out for those folks that are coming from C Python that may not have done embedded Python, is that the boards that we run on both micro Python and circuit Python, we're very much in Moore's Law territory. Still, the first board that I supported is 48 megahertz but the TnT14 runs at 600 megahertz. So we can get a lot of speed within this domain by paying a few dollars more. That's important to realize is that like the things that we do for speed, may not be The things that you would do in C Python. Interesting. Yeah, there's there's hardly a make the computer faster answer. At the C Python level, we do kind of have a turbo button if we can just clock the CPU faster.
Yeah, awesome. My Pentium 90 had a turbo button. I loved it.
And it was probably just as fast as what we're running. Micro Python and Circuit python
on now how interesting Yeah, for sure. All right, you guys. Well, we could go on and on and on about this. And maybe we'll have to do another episode. But I think we're probably out of time. So I'm gonna ask you a couple of wrap up questions I normally ask the editor, and PyPI library. Maybe we'll go ahead and do that. But I want to throw in one more thing as well. So let's do editor First, if you're gonna write some code that runs on either circuit, or micro Python devices, what editor do you use? I use VIM since day one I write on Scott, I use Sublime Text. Well, very good, very good. Notable PyPI package something out there. That's pretty cool. I've seen a bunch of things going by in the live chat as we're talking, it's very active today.
So I think httppy, is really quite a cool tool for, like, instead of W get 100% move to
set up by httpy, I guess is how Yeah, it's, it's like curl or w get, but you get like syntax highlighting for your response. It's beautiful.
And it's actually a good tool for when you're like working with micro Python, if micro Python is actually accepts, you know, HTTP, it's not just a sort of a pretty printing, it's, um, it's good for for actually workflow as well.
Yeah. Well, Scott, you got one to recommend
for the folks in C Python, and we're getting into hardware, if you have a Raspberry Pi blink is great. linka Okay, is the foundation, you'll want to find a device that you're interested in using and then you can use blinka. Yeah, I don't know. That's a really good, uh, the http.py is a good one. I'll have to take a look at that.
Yeah, I've completely switched all my servers, even on my desktop to just have that for testing thing. It's really, really good. Okay, here's the extra third question that normally we don't get. So if you're going to work on a project, I have all these ideas of things that I would love to create, and stuff, but I don't ever know really what the right hardware for it is. So I guess Damon, you first if you're going to work on something, and you've got some idea, you know, what kind of board would you get? Maybe actually give us a little background? Like the scope of the idea, the context, but what board would you play with the people are thinking of getting into stuff and playing with it and so on?
Yeah, that's a good question. It really depends on the project. If you want something like the PY board, we started making and selling that like eight years ago, that was the first Kickstarter. And we still sell a lot of these, the original pi board dumb down a little bit out of that page. Yeah, that one. And that's just a really good general purpose workhorse with good iOS support. And I use it still today to do things. And that's really cool. If you want high performance Wi Fi Bluetooth, you could just scroll back up a bit in the new pie board D is what you what you need, that, you know that has really fast Wi Fi and really good Bluetooth support. The Raspberry Pi Pico i think is a really another really good option if you want something that has is relatively cheap, and has good functionality and this new Pio programmable IO stuff that Scott was talking about. That's also a really cool option. There's a whole lot of stuff out there. Yeah, there's a lot of choice. And it's all really good choice. Exciting.
Yeah, very exciting. And not super expensive. As y'all were saying like yeah, them and try them. It's not a huge investment. Scott, what's your your dream board that you would recommend that board you would start with,
I don't think there's any one board, I see some people trying to make this particular board they have do something that doesn't necessarily do very well. So what I recommend people do is actually go to learn.adafruit.com, which is where Adafruit has all of our tutorials, and look there, find a project that is close, or exactly what you want to do. And then you'll see all of the stuff that you need to do that. That's where I would start because not only are you picking the hardware that you that you could use to do what you want, but you're also getting all the software to do it as well. You're definitely getting a head start by starting from an existing project. Yeah, that's
an interesting perspective. Like instead of what board do I want, like what project what thing do I want to create and solve now what hardware Do I need to like, facilitate that?
Yeah. And then the other thing you can do is if you go to circuit python.org/downloads, you actually can type different features like you want to see all the BLE boards or the Wi Fi boards, it will filter out the boards there for you. Those are all the boards that circuit Python runs on Bernie, Bernie
are you guys well, thank you for being here and sharing this it's it's really cool to see the two projects working more closely together. So final call to action. People want to get started one from each you I guess like what what would you tell people?
Well go to micropython.org go to forum.micropattern.org where our forum is that sort of the most active place for discussion. And then you'd have github micropython/micropython is also where all of the development action is
Scott for circuit Python, you can go to circuitpython.org. And the slash downloads is particularly useful if you happen to have a device already in hand, that will get you the file for that particular device. If you want to hang out with us that are working on circuit Python, we do have an Adafruit Discord server, everybody's welcome to join, you can go to the URL adafru.it/discord. That's the short link for it. And that will get you in there, you'll see there's a circuit Python dev channel, that's where we coordinate all the development. And on GitHub where github.com/ Adafruit/circuit Python, we're moving more and more to we have a circuit Python organization as well. So maybe at some point will do will be github.com/circuitpython/,
right, And I was also just gonna throw out that you do a fair number of live stream twitch do things you maybe just tell people about that as well, if they want to catch you there.
Yeah, so I started live streaming kind of like as the pandemic ramped up as just like something I've wanted to do. So I started doing it regularly. I do it at 2pm Pacific on the Adafruit channels. So you can go to youtube.com/Adafruit. It's called Deep Dive with Scott, there's a playlist there, they tend to be about two hours or more and very casual, no editing, but I answer questions and show off in into the weeds of circuit Python stuff. And we've gotten a lot of contributors out of that, which has been great. Yeah. So if you want to hang out on a Friday afternoon, everybody's welcome to do that. And we've talked to Damian about tuning that at some point as well. Well,
I look forward to seeing you both over there as well. So thanks for being on the show. Thank you. Thanks. You bet. This has been another episode of talk Python to me. Our guests on this episode were Damian George and Scott shockcraft. It's been brought to you by SENTRY and LINODE, and the transcripts are sponsored by Assembly AI. Take some stress out of your life get notified immediately about errors in your web applications with Sentry . Just visit talk python.fm/sentry and get started for free and use the promo code talkpythontome2021. When you sign up, simplify your infrastructure and cut your code bills in half with Linode. Linux virtual machines develop, deploy and scale your modern applications faster and easier. Visit 'talkpython.fm/linode' and click the Create free account button to get started. Transcripts for this and all of our episodes are brought to you by assembly AI. Do you need a great automatic speech to text API get human level accuracy in just a few lines of code visit 'talkpython.fm/assemblyAI'. On level up your Python we have one of the largest catalogs of Python video courses over at talk Python. Our content ranges from true beginners to deeply advanced topics like memory and async. And best of all, there's not a subscription insight. Check it out for yourself at 'training.talkpython.fm'. Be sure to subscribe to the show, open your favorite podcast app and search for Python. We should be right at the top. You can also find the iTunes feed at  /iTunes, the Google Play feed at /play and the direct RSS feed at /RSS on talk python.fm. We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at 'talkpython.fm/youtube'. This is your host Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and write some Python code
